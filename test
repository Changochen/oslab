
kernel.bin:     file format elf32-i386


Disassembly of section .text:

00100000 <serial_idle>:
	outb(SERIAL_PORT + 2, 0xC7);
	outb(SERIAL_PORT + 4, 0x0B);
}

static inline
int serial_idle(void) {
  100000:	55                   	push   %ebp
  100001:	89 e5                	mov    %esp,%ebp
  100003:	83 ec 10             	sub    $0x10,%esp
  100006:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  10000d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100010:	89 c2                	mov    %eax,%edx
  100012:	ec                   	in     (%dx),%al
  100013:	88 45 fb             	mov    %al,-0x5(%ebp)
	return data;
  100016:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
	return (inb(SERIAL_PORT + 5) & 0x20) != 0;
  10001a:	0f b6 c0             	movzbl %al,%eax
  10001d:	83 e0 20             	and    $0x20,%eax
  100020:	85 c0                	test   %eax,%eax
  100022:	0f 95 c0             	setne  %al
  100025:	0f b6 c0             	movzbl %al,%eax
}
  100028:	c9                   	leave  
  100029:	c3                   	ret    

0010002a <serial_printc>:

static inline
void serial_printc(char ch) {
  10002a:	55                   	push   %ebp
  10002b:	89 e5                	mov    %esp,%ebp
  10002d:	83 ec 14             	sub    $0x14,%esp
  100030:	8b 45 08             	mov    0x8(%ebp),%eax
  100033:	88 45 ec             	mov    %al,-0x14(%ebp)
	while (!serial_idle());
  100036:	90                   	nop
  100037:	e8 c4 ff ff ff       	call   100000 <serial_idle>
  10003c:	85 c0                	test   %eax,%eax
  10003e:	74 f7                	je     100037 <serial_printc+0xd>
	outb(SERIAL_PORT, ch);
  100040:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  100044:	0f b6 c0             	movzbl %al,%eax
  100047:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)
  10004e:	88 45 fb             	mov    %al,-0x5(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  100051:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  100055:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100058:	ee                   	out    %al,(%dx)
}
  100059:	90                   	nop
  10005a:	c9                   	leave  
  10005b:	c3                   	ret    

0010005c <set_timer_intr_handler>:
#include <lib/serial.h>
static void (*do_timer)(void);
static void (*do_keyboard)(int);

void
set_timer_intr_handler( void (*ptr)(void) ) {
  10005c:	55                   	push   %ebp
  10005d:	89 e5                	mov    %esp,%ebp
	do_timer = ptr;
  10005f:	8b 45 08             	mov    0x8(%ebp),%eax
  100062:	a3 a0 30 10 00       	mov    %eax,0x1030a0
}
  100067:	90                   	nop
  100068:	5d                   	pop    %ebp
  100069:	c3                   	ret    

0010006a <set_keyboard_intr_handler>:
void
set_keyboard_intr_handler( void (*ptr)(int) ) {
  10006a:	55                   	push   %ebp
  10006b:	89 e5                	mov    %esp,%ebp
	do_keyboard = ptr;
  10006d:	8b 45 08             	mov    0x8(%ebp),%eax
  100070:	a3 a4 30 10 00       	mov    %eax,0x1030a4
}
  100075:	90                   	nop
  100076:	5d                   	pop    %ebp
  100077:	c3                   	ret    

00100078 <irq_handle>:

void do_syscall(struct TrapFrame *);
/* TrapFrame的定义在include/x86/memory.h
 * 请仔细理解这段程序的含义，这些内容将在后续的实验中被反复使用。 */
void
irq_handle(struct TrapFrame *tf) {
  100078:	55                   	push   %ebp
  100079:	89 e5                	mov    %esp,%ebp
  10007b:	83 ec 28             	sub    $0x28,%esp
	printf("%d\n",tf->irq);
  10007e:	8b 45 08             	mov    0x8(%ebp),%eax
  100081:	8b 40 20             	mov    0x20(%eax),%eax
  100084:	83 ec 08             	sub    $0x8,%esp
  100087:	50                   	push   %eax
  100088:	68 60 19 10 00       	push   $0x101960
  10008d:	e8 1c 0d 00 00       	call   100dae <printf>
  100092:	83 c4 10             	add    $0x10,%esp
	if(tf->irq < 1000) {
  100095:	8b 45 08             	mov    0x8(%ebp),%eax
  100098:	8b 40 20             	mov    0x20(%eax),%eax
  10009b:	3d e7 03 00 00       	cmp    $0x3e7,%eax
		else {
			//printk("%s, %d: Unexpected exception #%d!\n", __FUNCTION__, __LINE__, tf->irq);
		}
	}

	if (tf->irq == 0x80) {
  1000a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1000a3:	8b 40 20             	mov    0x20(%eax),%eax
  1000a6:	3d 80 00 00 00       	cmp    $0x80,%eax
  1000ab:	75 13                	jne    1000c0 <irq_handle+0x48>
		do_syscall(tf);
  1000ad:	83 ec 0c             	sub    $0xc,%esp
  1000b0:	ff 75 08             	pushl  0x8(%ebp)
  1000b3:	e8 2a 04 00 00       	call   1004e2 <do_syscall>
  1000b8:	83 c4 10             	add    $0x10,%esp
		serial_printc('k');
		do_keyboard(code);
	} else {

	}
}
  1000bb:	e9 af 00 00 00       	jmp    10016f <irq_handle+0xf7>
	}

	if (tf->irq == 0x80) {
		do_syscall(tf);
	}
	else if (tf->irq == 1000) {
  1000c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1000c3:	8b 40 20             	mov    0x20(%eax),%eax
  1000c6:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  1000cb:	75 0c                	jne    1000d9 <irq_handle+0x61>
		do_timer();
  1000cd:	a1 a0 30 10 00       	mov    0x1030a0,%eax
  1000d2:	ff d0                	call   *%eax
		serial_printc('k');
		do_keyboard(code);
	} else {

	}
}
  1000d4:	e9 96 00 00 00       	jmp    10016f <irq_handle+0xf7>
	if (tf->irq == 0x80) {
		do_syscall(tf);
	}
	else if (tf->irq == 1000) {
		do_timer();
	} else if (tf->irq == 1001) {
  1000d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1000dc:	8b 40 20             	mov    0x20(%eax),%eax
  1000df:	3d e9 03 00 00       	cmp    $0x3e9,%eax
  1000e4:	0f 85 85 00 00 00    	jne    10016f <irq_handle+0xf7>
  1000ea:	c7 45 f0 60 00 00 00 	movl   $0x60,-0x10(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  1000f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1000f4:	89 c2                	mov    %eax,%edx
  1000f6:	ec                   	in     (%dx),%al
  1000f7:	88 45 dc             	mov    %al,-0x24(%ebp)
	return data;
  1000fa:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
		uint32_t code = inb(0x60);
  1000fe:	0f b6 c0             	movzbl %al,%eax
  100101:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100104:	c7 45 e8 61 00 00 00 	movl   $0x61,-0x18(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  10010b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10010e:	89 c2                	mov    %eax,%edx
  100110:	ec                   	in     (%dx),%al
  100111:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
  100114:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
		uint32_t val = inb(0x61);
  100118:	0f b6 c0             	movzbl %al,%eax
  10011b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		outb(0x61, val | 0x80);
  10011e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100121:	83 c8 80             	or     $0xffffff80,%eax
  100124:	0f b6 c0             	movzbl %al,%eax
  100127:	c7 45 e4 61 00 00 00 	movl   $0x61,-0x1c(%ebp)
  10012e:	88 45 de             	mov    %al,-0x22(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  100131:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
  100135:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  100138:	ee                   	out    %al,(%dx)
		outb(0x61, val);
  100139:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10013c:	0f b6 c0             	movzbl %al,%eax
  10013f:	c7 45 e0 61 00 00 00 	movl   $0x61,-0x20(%ebp)
  100146:	88 45 df             	mov    %al,-0x21(%ebp)
  100149:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  10014d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  100150:	ee                   	out    %al,(%dx)
		serial_printc('k');
  100151:	83 ec 0c             	sub    $0xc,%esp
  100154:	6a 6b                	push   $0x6b
  100156:	e8 cf fe ff ff       	call   10002a <serial_printc>
  10015b:	83 c4 10             	add    $0x10,%esp
		do_keyboard(code);
  10015e:	a1 a4 30 10 00       	mov    0x1030a4,%eax
  100163:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100166:	83 ec 0c             	sub    $0xc,%esp
  100169:	52                   	push   %edx
  10016a:	ff d0                	call   *%eax
  10016c:	83 c4 10             	add    $0x10,%esp
	} else {

	}
}
  10016f:	90                   	nop
  100170:	c9                   	leave  
  100171:	c3                   	ret    

00100172 <save_idt>:
	asm volatile("hlt");
}

/* 修改IDRT */
static inline void
save_idt(void *addr, uint32_t size) {
  100172:	55                   	push   %ebp
  100173:	89 e5                	mov    %esp,%ebp
	static volatile uint16_t data[3];
	data[0] = size - 1;
  100175:	8b 45 0c             	mov    0xc(%ebp),%eax
  100178:	83 e8 01             	sub    $0x1,%eax
  10017b:	66 a3 a8 30 10 00    	mov    %ax,0x1030a8
	data[1] = (uint32_t)addr;
  100181:	8b 45 08             	mov    0x8(%ebp),%eax
  100184:	66 a3 aa 30 10 00    	mov    %ax,0x1030aa
	data[2] = ((uint32_t)addr) >> 16;
  10018a:	8b 45 08             	mov    0x8(%ebp),%eax
  10018d:	c1 e8 10             	shr    $0x10,%eax
  100190:	66 a3 ac 30 10 00    	mov    %ax,0x1030ac
	asm volatile("lidt (%0)" : : "r"(data));
  100196:	b8 a8 30 10 00       	mov    $0x1030a8,%eax
  10019b:	0f 01 18             	lidtl  (%eax)
}
  10019e:	90                   	nop
  10019f:	5d                   	pop    %ebp
  1001a0:	c3                   	ret    

001001a1 <set_intr>:
/* IDT表的内容 */
struct GateDescriptor idt[NR_IRQ];

/* 初始化一个中断门(interrupt gate) */
static void
set_intr(struct GateDescriptor *ptr, uint32_t selector, uint32_t offset, uint32_t dpl) {
  1001a1:	55                   	push   %ebp
  1001a2:	89 e5                	mov    %esp,%ebp
	ptr->offset_15_0 = offset & 0xFFFF;
  1001a4:	8b 45 10             	mov    0x10(%ebp),%eax
  1001a7:	89 c2                	mov    %eax,%edx
  1001a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1001ac:	66 89 10             	mov    %dx,(%eax)
	ptr->segment = selector << 3;
  1001af:	8b 45 0c             	mov    0xc(%ebp),%eax
  1001b2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  1001b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1001bc:	66 89 50 02          	mov    %dx,0x2(%eax)
	ptr->pad0 = 0;
  1001c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1001c3:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	ptr->type = INTERRUPT_GATE_32;
  1001c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1001ca:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  1001ce:	83 e2 f0             	and    $0xfffffff0,%edx
  1001d1:	83 ca 0e             	or     $0xe,%edx
  1001d4:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->system = 0;
  1001d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1001da:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  1001de:	83 e2 ef             	and    $0xffffffef,%edx
  1001e1:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->privilege_level = dpl;
  1001e4:	8b 45 14             	mov    0x14(%ebp),%eax
  1001e7:	83 e0 03             	and    $0x3,%eax
  1001ea:	89 c2                	mov    %eax,%edx
  1001ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1001ef:	83 e2 03             	and    $0x3,%edx
  1001f2:	89 d1                	mov    %edx,%ecx
  1001f4:	c1 e1 05             	shl    $0x5,%ecx
  1001f7:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  1001fb:	83 e2 9f             	and    $0xffffff9f,%edx
  1001fe:	09 ca                	or     %ecx,%edx
  100200:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->present = 1;
  100203:	8b 45 08             	mov    0x8(%ebp),%eax
  100206:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  10020a:	83 ca 80             	or     $0xffffff80,%edx
  10020d:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
  100210:	8b 45 10             	mov    0x10(%ebp),%eax
  100213:	c1 e8 10             	shr    $0x10,%eax
  100216:	89 c2                	mov    %eax,%edx
  100218:	8b 45 08             	mov    0x8(%ebp),%eax
  10021b:	66 89 50 06          	mov    %dx,0x6(%eax)
}
  10021f:	90                   	nop
  100220:	5d                   	pop    %ebp
  100221:	c3                   	ret    

00100222 <set_trap>:

/* 初始化一个陷阱门(trap gate) */
static void
set_trap(struct GateDescriptor *ptr, uint32_t selector, uint32_t offset, uint32_t dpl) {
  100222:	55                   	push   %ebp
  100223:	89 e5                	mov    %esp,%ebp
	ptr->offset_15_0 = offset & 0xFFFF;
  100225:	8b 45 10             	mov    0x10(%ebp),%eax
  100228:	89 c2                	mov    %eax,%edx
  10022a:	8b 45 08             	mov    0x8(%ebp),%eax
  10022d:	66 89 10             	mov    %dx,(%eax)
	ptr->segment = selector << 3;
  100230:	8b 45 0c             	mov    0xc(%ebp),%eax
  100233:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  10023a:	8b 45 08             	mov    0x8(%ebp),%eax
  10023d:	66 89 50 02          	mov    %dx,0x2(%eax)
	ptr->pad0 = 0;
  100241:	8b 45 08             	mov    0x8(%ebp),%eax
  100244:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	ptr->type = TRAP_GATE_32;
  100248:	8b 45 08             	mov    0x8(%ebp),%eax
  10024b:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  10024f:	83 ca 0f             	or     $0xf,%edx
  100252:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->system = 0;
  100255:	8b 45 08             	mov    0x8(%ebp),%eax
  100258:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  10025c:	83 e2 ef             	and    $0xffffffef,%edx
  10025f:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->privilege_level = dpl;
  100262:	8b 45 14             	mov    0x14(%ebp),%eax
  100265:	83 e0 03             	and    $0x3,%eax
  100268:	89 c2                	mov    %eax,%edx
  10026a:	8b 45 08             	mov    0x8(%ebp),%eax
  10026d:	83 e2 03             	and    $0x3,%edx
  100270:	89 d1                	mov    %edx,%ecx
  100272:	c1 e1 05             	shl    $0x5,%ecx
  100275:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  100279:	83 e2 9f             	and    $0xffffff9f,%edx
  10027c:	09 ca                	or     %ecx,%edx
  10027e:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->present = 1;
  100281:	8b 45 08             	mov    0x8(%ebp),%eax
  100284:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  100288:	83 ca 80             	or     $0xffffff80,%edx
  10028b:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
  10028e:	8b 45 10             	mov    0x10(%ebp),%eax
  100291:	c1 e8 10             	shr    $0x10,%eax
  100294:	89 c2                	mov    %eax,%edx
  100296:	8b 45 08             	mov    0x8(%ebp),%eax
  100299:	66 89 50 06          	mov    %dx,0x6(%eax)
}
  10029d:	90                   	nop
  10029e:	5d                   	pop    %ebp
  10029f:	c3                   	ret    

001002a0 <init_idt>:
void vec12();
void vec13();
void vecsys();
void irq_empty();

void init_idt() {
  1002a0:	55                   	push   %ebp
  1002a1:	89 e5                	mov    %esp,%ebp
  1002a3:	83 ec 10             	sub    $0x10,%esp
	int i;
	/* 为了防止系统异常终止，所有irq都有处理函数(irq_empty)。 */
	for (i = 0; i < NR_IRQ; i ++) {
  1002a6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1002ad:	eb 22                	jmp    1002d1 <init_idt+0x31>
		set_trap(idt + i, SEG_KERNEL_CODE, (uint32_t)irq_empty, DPL_KERNEL);
  1002af:	ba 60 0a 10 00       	mov    $0x100a60,%edx
  1002b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002b7:	c1 e0 03             	shl    $0x3,%eax
  1002ba:	05 40 31 10 00       	add    $0x103140,%eax
  1002bf:	6a 00                	push   $0x0
  1002c1:	52                   	push   %edx
  1002c2:	6a 01                	push   $0x1
  1002c4:	50                   	push   %eax
  1002c5:	e8 58 ff ff ff       	call   100222 <set_trap>
  1002ca:	83 c4 10             	add    $0x10,%esp
void irq_empty();

void init_idt() {
	int i;
	/* 为了防止系统异常终止，所有irq都有处理函数(irq_empty)。 */
	for (i = 0; i < NR_IRQ; i ++) {
  1002cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1002d1:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
  1002d8:	7e d5                	jle    1002af <init_idt+0xf>
		set_trap(idt + i, SEG_KERNEL_CODE, (uint32_t)irq_empty, DPL_KERNEL);
	}

	/* 设置异常的中断处理 */
	set_trap(idt + 0, SEG_KERNEL_CODE, (uint32_t)vec0, DPL_KERNEL);
  1002da:	b8 e8 09 10 00       	mov    $0x1009e8,%eax
  1002df:	6a 00                	push   $0x0
  1002e1:	50                   	push   %eax
  1002e2:	6a 01                	push   $0x1
  1002e4:	68 40 31 10 00       	push   $0x103140
  1002e9:	e8 34 ff ff ff       	call   100222 <set_trap>
  1002ee:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 1, SEG_KERNEL_CODE, (uint32_t)vec1, DPL_KERNEL);
  1002f1:	ba ee 09 10 00       	mov    $0x1009ee,%edx
  1002f6:	b8 48 31 10 00       	mov    $0x103148,%eax
  1002fb:	6a 00                	push   $0x0
  1002fd:	52                   	push   %edx
  1002fe:	6a 01                	push   $0x1
  100300:	50                   	push   %eax
  100301:	e8 1c ff ff ff       	call   100222 <set_trap>
  100306:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 2, SEG_KERNEL_CODE, (uint32_t)vec2, DPL_KERNEL);
  100309:	ba f4 09 10 00       	mov    $0x1009f4,%edx
  10030e:	b8 50 31 10 00       	mov    $0x103150,%eax
  100313:	6a 00                	push   $0x0
  100315:	52                   	push   %edx
  100316:	6a 01                	push   $0x1
  100318:	50                   	push   %eax
  100319:	e8 04 ff ff ff       	call   100222 <set_trap>
  10031e:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 3, SEG_KERNEL_CODE, (uint32_t)vec3, DPL_KERNEL);
  100321:	ba fa 09 10 00       	mov    $0x1009fa,%edx
  100326:	b8 58 31 10 00       	mov    $0x103158,%eax
  10032b:	6a 00                	push   $0x0
  10032d:	52                   	push   %edx
  10032e:	6a 01                	push   $0x1
  100330:	50                   	push   %eax
  100331:	e8 ec fe ff ff       	call   100222 <set_trap>
  100336:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 4, SEG_KERNEL_CODE, (uint32_t)vec4, DPL_KERNEL);
  100339:	ba 00 0a 10 00       	mov    $0x100a00,%edx
  10033e:	b8 60 31 10 00       	mov    $0x103160,%eax
  100343:	6a 00                	push   $0x0
  100345:	52                   	push   %edx
  100346:	6a 01                	push   $0x1
  100348:	50                   	push   %eax
  100349:	e8 d4 fe ff ff       	call   100222 <set_trap>
  10034e:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 5, SEG_KERNEL_CODE, (uint32_t)vec5, DPL_KERNEL);
  100351:	ba 06 0a 10 00       	mov    $0x100a06,%edx
  100356:	b8 68 31 10 00       	mov    $0x103168,%eax
  10035b:	6a 00                	push   $0x0
  10035d:	52                   	push   %edx
  10035e:	6a 01                	push   $0x1
  100360:	50                   	push   %eax
  100361:	e8 bc fe ff ff       	call   100222 <set_trap>
  100366:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 6, SEG_KERNEL_CODE, (uint32_t)vec6, DPL_KERNEL);
  100369:	ba 0c 0a 10 00       	mov    $0x100a0c,%edx
  10036e:	b8 70 31 10 00       	mov    $0x103170,%eax
  100373:	6a 00                	push   $0x0
  100375:	52                   	push   %edx
  100376:	6a 01                	push   $0x1
  100378:	50                   	push   %eax
  100379:	e8 a4 fe ff ff       	call   100222 <set_trap>
  10037e:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 7, SEG_KERNEL_CODE, (uint32_t)vec7, DPL_KERNEL);
  100381:	ba 12 0a 10 00       	mov    $0x100a12,%edx
  100386:	b8 78 31 10 00       	mov    $0x103178,%eax
  10038b:	6a 00                	push   $0x0
  10038d:	52                   	push   %edx
  10038e:	6a 01                	push   $0x1
  100390:	50                   	push   %eax
  100391:	e8 8c fe ff ff       	call   100222 <set_trap>
  100396:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 8, SEG_KERNEL_CODE, (uint32_t)vec8, DPL_KERNEL);
  100399:	ba 18 0a 10 00       	mov    $0x100a18,%edx
  10039e:	b8 80 31 10 00       	mov    $0x103180,%eax
  1003a3:	6a 00                	push   $0x0
  1003a5:	52                   	push   %edx
  1003a6:	6a 01                	push   $0x1
  1003a8:	50                   	push   %eax
  1003a9:	e8 74 fe ff ff       	call   100222 <set_trap>
  1003ae:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 9, SEG_KERNEL_CODE, (uint32_t)vec9, DPL_KERNEL);
  1003b1:	ba 1e 0a 10 00       	mov    $0x100a1e,%edx
  1003b6:	b8 88 31 10 00       	mov    $0x103188,%eax
  1003bb:	6a 00                	push   $0x0
  1003bd:	52                   	push   %edx
  1003be:	6a 01                	push   $0x1
  1003c0:	50                   	push   %eax
  1003c1:	e8 5c fe ff ff       	call   100222 <set_trap>
  1003c6:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 10, SEG_KERNEL_CODE, (uint32_t)vec10, DPL_KERNEL);
  1003c9:	ba 24 0a 10 00       	mov    $0x100a24,%edx
  1003ce:	b8 90 31 10 00       	mov    $0x103190,%eax
  1003d3:	6a 00                	push   $0x0
  1003d5:	52                   	push   %edx
  1003d6:	6a 01                	push   $0x1
  1003d8:	50                   	push   %eax
  1003d9:	e8 44 fe ff ff       	call   100222 <set_trap>
  1003de:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 11, SEG_KERNEL_CODE, (uint32_t)vec11, DPL_KERNEL);
  1003e1:	ba 2a 0a 10 00       	mov    $0x100a2a,%edx
  1003e6:	b8 98 31 10 00       	mov    $0x103198,%eax
  1003eb:	6a 00                	push   $0x0
  1003ed:	52                   	push   %edx
  1003ee:	6a 01                	push   $0x1
  1003f0:	50                   	push   %eax
  1003f1:	e8 2c fe ff ff       	call   100222 <set_trap>
  1003f6:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 12, SEG_KERNEL_CODE, (uint32_t)vec12, DPL_KERNEL);
  1003f9:	ba 30 0a 10 00       	mov    $0x100a30,%edx
  1003fe:	b8 a0 31 10 00       	mov    $0x1031a0,%eax
  100403:	6a 00                	push   $0x0
  100405:	52                   	push   %edx
  100406:	6a 01                	push   $0x1
  100408:	50                   	push   %eax
  100409:	e8 14 fe ff ff       	call   100222 <set_trap>
  10040e:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 13, SEG_KERNEL_CODE, (uint32_t)vec13, DPL_KERNEL);
  100411:	ba 36 0a 10 00       	mov    $0x100a36,%edx
  100416:	b8 a8 31 10 00       	mov    $0x1031a8,%eax
  10041b:	6a 00                	push   $0x0
  10041d:	52                   	push   %edx
  10041e:	6a 01                	push   $0x1
  100420:	50                   	push   %eax
  100421:	e8 fc fd ff ff       	call   100222 <set_trap>
  100426:	83 c4 10             	add    $0x10,%esp
	set_trap(idt + 0x80, SEG_KERNEL_CODE, (uint32_t)vecsys, DPL_USER);
  100429:	ba 3c 0a 10 00       	mov    $0x100a3c,%edx
  10042e:	b8 40 35 10 00       	mov    $0x103540,%eax
  100433:	6a 03                	push   $0x3
  100435:	52                   	push   %edx
  100436:	6a 01                	push   $0x1
  100438:	50                   	push   %eax
  100439:	e8 e4 fd ff ff       	call   100222 <set_trap>
  10043e:	83 c4 10             	add    $0x10,%esp

	/* 设置外部中断的处理 */

	set_intr(idt + 32, SEG_KERNEL_CODE, (uint32_t)irq0, DPL_KERNEL);
  100441:	ba 45 0a 10 00       	mov    $0x100a45,%edx
  100446:	b8 40 32 10 00       	mov    $0x103240,%eax
  10044b:	6a 00                	push   $0x0
  10044d:	52                   	push   %edx
  10044e:	6a 01                	push   $0x1
  100450:	50                   	push   %eax
  100451:	e8 4b fd ff ff       	call   1001a1 <set_intr>
  100456:	83 c4 10             	add    $0x10,%esp
	set_intr(idt + 33, SEG_KERNEL_CODE, (uint32_t)irq1, DPL_KERNEL);
  100459:	ba 4e 0a 10 00       	mov    $0x100a4e,%edx
  10045e:	b8 48 32 10 00       	mov    $0x103248,%eax
  100463:	6a 00                	push   $0x0
  100465:	52                   	push   %edx
  100466:	6a 01                	push   $0x1
  100468:	50                   	push   %eax
  100469:	e8 33 fd ff ff       	call   1001a1 <set_intr>
  10046e:	83 c4 10             	add    $0x10,%esp
	/* 写入IDT */
	save_idt(idt, sizeof(idt));
  100471:	68 00 08 00 00       	push   $0x800
  100476:	68 40 31 10 00       	push   $0x103140
  10047b:	e8 f2 fc ff ff       	call   100172 <save_idt>
  100480:	83 c4 08             	add    $0x8,%esp
}
  100483:	90                   	nop
  100484:	c9                   	leave  
  100485:	c3                   	ret    

00100486 <serial_idle>:
	outb(SERIAL_PORT + 2, 0xC7);
	outb(SERIAL_PORT + 4, 0x0B);
}

static inline
int serial_idle(void) {
  100486:	55                   	push   %ebp
  100487:	89 e5                	mov    %esp,%ebp
  100489:	83 ec 10             	sub    $0x10,%esp
  10048c:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  100493:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100496:	89 c2                	mov    %eax,%edx
  100498:	ec                   	in     (%dx),%al
  100499:	88 45 fb             	mov    %al,-0x5(%ebp)
	return data;
  10049c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
	return (inb(SERIAL_PORT + 5) & 0x20) != 0;
  1004a0:	0f b6 c0             	movzbl %al,%eax
  1004a3:	83 e0 20             	and    $0x20,%eax
  1004a6:	85 c0                	test   %eax,%eax
  1004a8:	0f 95 c0             	setne  %al
  1004ab:	0f b6 c0             	movzbl %al,%eax
}
  1004ae:	c9                   	leave  
  1004af:	c3                   	ret    

001004b0 <serial_printc>:

static inline
void serial_printc(char ch) {
  1004b0:	55                   	push   %ebp
  1004b1:	89 e5                	mov    %esp,%ebp
  1004b3:	83 ec 14             	sub    $0x14,%esp
  1004b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1004b9:	88 45 ec             	mov    %al,-0x14(%ebp)
	while (!serial_idle());
  1004bc:	90                   	nop
  1004bd:	e8 c4 ff ff ff       	call   100486 <serial_idle>
  1004c2:	85 c0                	test   %eax,%eax
  1004c4:	74 f7                	je     1004bd <serial_printc+0xd>
	outb(SERIAL_PORT, ch);
  1004c6:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  1004ca:	0f b6 c0             	movzbl %al,%eax
  1004cd:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)
  1004d4:	88 45 fb             	mov    %al,-0x5(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  1004d7:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  1004db:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1004de:	ee                   	out    %al,(%dx)
}
  1004df:	90                   	nop
  1004e0:	c9                   	leave  
  1004e1:	c3                   	ret    

001004e2 <do_syscall>:
#include <lib/syscall.h>

extern timer_handler timer_handlers[TIMER_HANDLERS_MAX];
extern uint32_t tick();

void do_syscall(struct TrapFrame *tf) {
  1004e2:	55                   	push   %ebp
  1004e3:	89 e5                	mov    %esp,%ebp
	//int i;
	switch(tf->eax) {
  1004e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1004e8:	8b 40 1c             	mov    0x1c(%eax),%eax
  1004eb:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  1004f0:	74 02                	je     1004f4 <do_syscall+0x12>
				}
			}
		break;
		*/
	}
}
  1004f2:	eb 13                	jmp    100507 <do_syscall+0x25>

void do_syscall(struct TrapFrame *tf) {
	//int i;
	switch(tf->eax) {
		case SYS_PRINT_CHAR:
			serial_printc(tf->ebx);
  1004f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1004f7:	8b 40 10             	mov    0x10(%eax),%eax
  1004fa:	0f be c0             	movsbl %al,%eax
  1004fd:	50                   	push   %eax
  1004fe:	e8 ad ff ff ff       	call   1004b0 <serial_printc>
  100503:	83 c4 04             	add    $0x4,%esp
		break;
  100506:	90                   	nop
				}
			}
		break;
		*/
	}
}
  100507:	90                   	nop
  100508:	c9                   	leave  
  100509:	c3                   	ret    

0010050a <enable_interrupt>:
	asm volatile("lidt (%0)" : : "r"(data));
}

/* 打开外部中断 */
static inline void
enable_interrupt(void) {
  10050a:	55                   	push   %ebp
  10050b:	89 e5                	mov    %esp,%ebp
	asm volatile("sti");
  10050d:	fb                   	sti    
}
  10050e:	90                   	nop
  10050f:	5d                   	pop    %ebp
  100510:	c3                   	ret    

00100511 <init_serial>:

#include "common.h"
#define SERIAL_PORT  0x3F8

static inline
void init_serial(void) {
  100511:	55                   	push   %ebp
  100512:	89 e5                	mov    %esp,%ebp
  100514:	83 ec 30             	sub    $0x30,%esp
  100517:	c7 45 fc f9 03 00 00 	movl   $0x3f9,-0x4(%ebp)
  10051e:	c6 45 dd 00          	movb   $0x0,-0x23(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  100522:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
  100526:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100529:	ee                   	out    %al,(%dx)
  10052a:	c7 45 f8 fb 03 00 00 	movl   $0x3fb,-0x8(%ebp)
  100531:	c6 45 de 80          	movb   $0x80,-0x22(%ebp)
  100535:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
  100539:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10053c:	ee                   	out    %al,(%dx)
  10053d:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%ebp)
  100544:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
  100548:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  10054c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10054f:	ee                   	out    %al,(%dx)
  100550:	c7 45 f0 f9 03 00 00 	movl   $0x3f9,-0x10(%ebp)
  100557:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
  10055b:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  10055f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100562:	ee                   	out    %al,(%dx)
  100563:	c7 45 ec fb 03 00 00 	movl   $0x3fb,-0x14(%ebp)
  10056a:	c6 45 e1 03          	movb   $0x3,-0x1f(%ebp)
  10056e:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  100572:	8b 55 ec             	mov    -0x14(%ebp),%edx
  100575:	ee                   	out    %al,(%dx)
  100576:	c7 45 e8 fa 03 00 00 	movl   $0x3fa,-0x18(%ebp)
  10057d:	c6 45 e2 c7          	movb   $0xc7,-0x1e(%ebp)
  100581:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
  100585:	8b 55 e8             	mov    -0x18(%ebp),%edx
  100588:	ee                   	out    %al,(%dx)
  100589:	c7 45 e4 fc 03 00 00 	movl   $0x3fc,-0x1c(%ebp)
  100590:	c6 45 e3 0b          	movb   $0xb,-0x1d(%ebp)
  100594:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  100598:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10059b:	ee                   	out    %al,(%dx)
	outb(SERIAL_PORT + 0, 0x01);
	outb(SERIAL_PORT + 1, 0x00);
	outb(SERIAL_PORT + 3, 0x03);
	outb(SERIAL_PORT + 2, 0xC7);
	outb(SERIAL_PORT + 4, 0x0B);
}
  10059c:	90                   	nop
  10059d:	c9                   	leave  
  10059e:	c3                   	ret    

0010059f <init_intr>:
#include "common.h"
#define IO_PIC1 0x20
#define IO_PIC2 0xA0
#define IRQ_OFFSET 0x20
#define IRQ_SLAVE 2
void init_intr(void){
  10059f:	55                   	push   %ebp
  1005a0:	89 e5                	mov    %esp,%ebp
  1005a2:	83 ec 50             	sub    $0x50,%esp
  1005a5:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
  1005ac:	c6 45 ba ff          	movb   $0xff,-0x46(%ebp)
  1005b0:	0f b6 45 ba          	movzbl -0x46(%ebp),%eax
  1005b4:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1005b7:	ee                   	out    %al,(%dx)
  1005b8:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
  1005bf:	c6 45 bb ff          	movb   $0xff,-0x45(%ebp)
  1005c3:	0f b6 45 bb          	movzbl -0x45(%ebp),%eax
  1005c7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1005ca:	ee                   	out    %al,(%dx)
  1005cb:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%ebp)
  1005d2:	c6 45 bc 11          	movb   $0x11,-0x44(%ebp)
  1005d6:	0f b6 45 bc          	movzbl -0x44(%ebp),%eax
  1005da:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1005dd:	ee                   	out    %al,(%dx)
  1005de:	c7 45 f0 21 00 00 00 	movl   $0x21,-0x10(%ebp)
  1005e5:	c6 45 bd 20          	movb   $0x20,-0x43(%ebp)
  1005e9:	0f b6 45 bd          	movzbl -0x43(%ebp),%eax
  1005ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1005f0:	ee                   	out    %al,(%dx)
  1005f1:	c7 45 ec 21 00 00 00 	movl   $0x21,-0x14(%ebp)
  1005f8:	c6 45 be 04          	movb   $0x4,-0x42(%ebp)
  1005fc:	0f b6 45 be          	movzbl -0x42(%ebp),%eax
  100600:	8b 55 ec             	mov    -0x14(%ebp),%edx
  100603:	ee                   	out    %al,(%dx)
  100604:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
  10060b:	c6 45 bf 03          	movb   $0x3,-0x41(%ebp)
  10060f:	0f b6 45 bf          	movzbl -0x41(%ebp),%eax
  100613:	8b 55 e8             	mov    -0x18(%ebp),%edx
  100616:	ee                   	out    %al,(%dx)
  100617:	c7 45 e4 a0 00 00 00 	movl   $0xa0,-0x1c(%ebp)
  10061e:	c6 45 c0 11          	movb   $0x11,-0x40(%ebp)
  100622:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
  100626:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  100629:	ee                   	out    %al,(%dx)
  10062a:	c7 45 e0 a1 00 00 00 	movl   $0xa1,-0x20(%ebp)
  100631:	c6 45 c1 28          	movb   $0x28,-0x3f(%ebp)
  100635:	0f b6 45 c1          	movzbl -0x3f(%ebp),%eax
  100639:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10063c:	ee                   	out    %al,(%dx)
  10063d:	c7 45 dc a1 00 00 00 	movl   $0xa1,-0x24(%ebp)
  100644:	c6 45 c2 02          	movb   $0x2,-0x3e(%ebp)
  100648:	0f b6 45 c2          	movzbl -0x3e(%ebp),%eax
  10064c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10064f:	ee                   	out    %al,(%dx)
  100650:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
  100657:	c6 45 c3 01          	movb   $0x1,-0x3d(%ebp)
  10065b:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
  10065f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  100662:	ee                   	out    %al,(%dx)
  100663:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%ebp)
  10066a:	c6 45 c4 68          	movb   $0x68,-0x3c(%ebp)
  10066e:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
  100672:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100675:	ee                   	out    %al,(%dx)
  100676:	c7 45 d0 20 00 00 00 	movl   $0x20,-0x30(%ebp)
  10067d:	c6 45 c5 0a          	movb   $0xa,-0x3b(%ebp)
  100681:	0f b6 45 c5          	movzbl -0x3b(%ebp),%eax
  100685:	8b 55 d0             	mov    -0x30(%ebp),%edx
  100688:	ee                   	out    %al,(%dx)
  100689:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%ebp)
  100690:	c6 45 c6 68          	movb   $0x68,-0x3a(%ebp)
  100694:	0f b6 45 c6          	movzbl -0x3a(%ebp),%eax
  100698:	8b 55 cc             	mov    -0x34(%ebp),%edx
  10069b:	ee                   	out    %al,(%dx)
  10069c:	c7 45 c8 a0 00 00 00 	movl   $0xa0,-0x38(%ebp)
  1006a3:	c6 45 c7 0a          	movb   $0xa,-0x39(%ebp)
  1006a7:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  1006ab:	8b 55 c8             	mov    -0x38(%ebp),%edx
  1006ae:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x68);             /* clear specific mask */
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);             /* OCW3 */
	outb(IO_PIC2, 0x0a);             /* OCW3 */
}
  1006af:	90                   	nop
  1006b0:	c9                   	leave  
  1006b1:	c3                   	ret    

001006b2 <init_timer>:
  .operate_mode = 2,  // rate generator, for more accuracy
  .access_mode  = 3,  // low byte / high byte, see below
  .channel      = 0,  // use channel 0
};

void init_timer(){
  1006b2:	55                   	push   %ebp
  1006b3:	89 e5                	mov    %esp,%ebp
  1006b5:	83 ec 20             	sub    $0x20,%esp
	int counter = PIT_FREQUENCE / HZ;
  1006b8:	c7 45 fc 9b 2e 00 00 	movl   $0x2e9b,-0x4(%ebp)
	outb(PORT_CMD, mode.val);
  1006bf:	0f b6 05 00 30 10 00 	movzbl 0x103000,%eax
  1006c6:	0f b6 c0             	movzbl %al,%eax
  1006c9:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)
  1006d0:	88 45 ed             	mov    %al,-0x13(%ebp)
  1006d3:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
  1006d7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1006da:	ee                   	out    %al,(%dx)
	outb(PORT_CH_0, counter & 0xFF);         // access low byte
  1006db:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1006de:	0f b6 c0             	movzbl %al,%eax
  1006e1:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
  1006e8:	88 45 ee             	mov    %al,-0x12(%ebp)
  1006eb:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
  1006ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1006f2:	ee                   	out    %al,(%dx)
	outb(PORT_CH_0, (counter >> 8) & 0xFF);  // access high byte
  1006f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1006f6:	c1 f8 08             	sar    $0x8,%eax
  1006f9:	0f b6 c0             	movzbl %al,%eax
  1006fc:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
  100703:	88 45 ef             	mov    %al,-0x11(%ebp)
  100706:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  10070a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10070d:	ee                   	out    %al,(%dx)
}
  10070e:	90                   	nop
  10070f:	c9                   	leave  
  100710:	c3                   	ret    

00100711 <waitdisk>:
#define SECTSIZE    512

static inline void
waitdisk(void) {
  100711:	55                   	push   %ebp
  100712:	89 e5                	mov    %esp,%ebp
  100714:	83 ec 10             	sub    $0x10,%esp
    while((inb(0x1F7) & 0xC0) != 0x40);
  100717:	90                   	nop
  100718:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  10071f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100722:	89 c2                	mov    %eax,%edx
  100724:	ec                   	in     (%dx),%al
  100725:	88 45 fb             	mov    %al,-0x5(%ebp)
	return data;
  100728:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  10072c:	0f b6 c0             	movzbl %al,%eax
  10072f:	25 c0 00 00 00       	and    $0xc0,%eax
  100734:	83 f8 40             	cmp    $0x40,%eax
  100737:	75 df                	jne    100718 <waitdisk+0x7>
}
  100739:	90                   	nop
  10073a:	c9                   	leave  
  10073b:	c3                   	ret    

0010073c <readsect>:

static inline void
readsect(void *dst, int offset) {
  10073c:	55                   	push   %ebp
  10073d:	89 e5                	mov    %esp,%ebp
  10073f:	83 ec 30             	sub    $0x30,%esp
    int i;
    waitdisk();
  100742:	e8 ca ff ff ff       	call   100711 <waitdisk>
  100747:	c7 45 f4 f2 01 00 00 	movl   $0x1f2,-0xc(%ebp)
  10074e:	c6 45 da 01          	movb   $0x1,-0x26(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  100752:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
  100756:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100759:	ee                   	out    %al,(%dx)
    outb(0x1F2, 1);
    outb(0x1F3, offset);
  10075a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10075d:	0f b6 c0             	movzbl %al,%eax
  100760:	c7 45 f0 f3 01 00 00 	movl   $0x1f3,-0x10(%ebp)
  100767:	88 45 db             	mov    %al,-0x25(%ebp)
  10076a:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
  10076e:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100771:	ee                   	out    %al,(%dx)
    outb(0x1F4, offset >> 8);
  100772:	8b 45 0c             	mov    0xc(%ebp),%eax
  100775:	c1 f8 08             	sar    $0x8,%eax
  100778:	0f b6 c0             	movzbl %al,%eax
  10077b:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%ebp)
  100782:	88 45 dc             	mov    %al,-0x24(%ebp)
  100785:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  100789:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10078c:	ee                   	out    %al,(%dx)
    outb(0x1F5, offset >> 16);
  10078d:	8b 45 0c             	mov    0xc(%ebp),%eax
  100790:	c1 f8 10             	sar    $0x10,%eax
  100793:	0f b6 c0             	movzbl %al,%eax
  100796:	c7 45 e8 f5 01 00 00 	movl   $0x1f5,-0x18(%ebp)
  10079d:	88 45 dd             	mov    %al,-0x23(%ebp)
  1007a0:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
  1007a4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1007a7:	ee                   	out    %al,(%dx)
    outb(0x1F6, (offset >> 24) | 0xE0);
  1007a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1007ab:	c1 f8 18             	sar    $0x18,%eax
  1007ae:	83 c8 e0             	or     $0xffffffe0,%eax
  1007b1:	0f b6 c0             	movzbl %al,%eax
  1007b4:	c7 45 e4 f6 01 00 00 	movl   $0x1f6,-0x1c(%ebp)
  1007bb:	88 45 de             	mov    %al,-0x22(%ebp)
  1007be:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
  1007c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1007c5:	ee                   	out    %al,(%dx)
  1007c6:	c7 45 e0 f7 01 00 00 	movl   $0x1f7,-0x20(%ebp)
  1007cd:	c6 45 df 20          	movb   $0x20,-0x21(%ebp)
  1007d1:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  1007d5:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1007d8:	ee                   	out    %al,(%dx)
    outb(0x1F7, 0x20);

    waitdisk();
  1007d9:	e8 33 ff ff ff       	call   100711 <waitdisk>
    for (i = 0; i < SECTSIZE / 4; i ++) {
  1007de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1007e5:	eb 29                	jmp    100810 <readsect+0xd4>
        ((int *)dst)[i] = inl(0x1F0);
  1007e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1007ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1007f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1007f4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  1007f7:	c7 45 f8 f0 01 00 00 	movl   $0x1f0,-0x8(%ebp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  1007fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100801:	89 c2                	mov    %eax,%edx
  100803:	ed                   	in     (%dx),%eax
  100804:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	return data;
  100807:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10080a:	89 01                	mov    %eax,(%ecx)
    outb(0x1F5, offset >> 16);
    outb(0x1F6, (offset >> 24) | 0xE0);
    outb(0x1F7, 0x20);

    waitdisk();
    for (i = 0; i < SECTSIZE / 4; i ++) {
  10080c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100810:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
  100814:	7e d1                	jle    1007e7 <readsect+0xab>
        ((int *)dst)[i] = inl(0x1F0);
    }
}
  100816:	90                   	nop
  100817:	c9                   	leave  
  100818:	c3                   	ret    

00100819 <readseg>:

static inline void
readseg(unsigned char *pa, int count, int offset) {
  100819:	55                   	push   %ebp
  10081a:	89 e5                	mov    %esp,%ebp
  10081c:	83 ec 10             	sub    $0x10,%esp
    unsigned char *epa;
    epa = pa + count;
  10081f:	8b 55 0c             	mov    0xc(%ebp),%edx
  100822:	8b 45 08             	mov    0x8(%ebp),%eax
  100825:	01 d0                	add    %edx,%eax
  100827:	89 45 fc             	mov    %eax,-0x4(%ebp)
    pa -= offset % SECTSIZE;
  10082a:	8b 45 10             	mov    0x10(%ebp),%eax
  10082d:	99                   	cltd   
  10082e:	c1 ea 17             	shr    $0x17,%edx
  100831:	01 d0                	add    %edx,%eax
  100833:	25 ff 01 00 00       	and    $0x1ff,%eax
  100838:	29 d0                	sub    %edx,%eax
  10083a:	f7 d8                	neg    %eax
  10083c:	01 45 08             	add    %eax,0x8(%ebp)
    offset = (offset / SECTSIZE) + 1;
  10083f:	8b 45 10             	mov    0x10(%ebp),%eax
  100842:	8d 90 ff 01 00 00    	lea    0x1ff(%eax),%edx
  100848:	85 c0                	test   %eax,%eax
  10084a:	0f 48 c2             	cmovs  %edx,%eax
  10084d:	c1 f8 09             	sar    $0x9,%eax
  100850:	83 c0 01             	add    $0x1,%eax
  100853:	89 45 10             	mov    %eax,0x10(%ebp)
    for(; pa < epa; pa += SECTSIZE, offset ++)
  100856:	eb 19                	jmp    100871 <readseg+0x58>
        readsect(pa, offset);
  100858:	ff 75 10             	pushl  0x10(%ebp)
  10085b:	ff 75 08             	pushl  0x8(%ebp)
  10085e:	e8 d9 fe ff ff       	call   10073c <readsect>
  100863:	83 c4 08             	add    $0x8,%esp
readseg(unsigned char *pa, int count, int offset) {
    unsigned char *epa;
    epa = pa + count;
    pa -= offset % SECTSIZE;
    offset = (offset / SECTSIZE) + 1;
    for(; pa < epa; pa += SECTSIZE, offset ++)
  100866:	81 45 08 00 02 00 00 	addl   $0x200,0x8(%ebp)
  10086d:	83 45 10 01          	addl   $0x1,0x10(%ebp)
  100871:	8b 45 08             	mov    0x8(%ebp),%eax
  100874:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  100877:	72 df                	jb     100858 <readseg+0x3f>
        readsect(pa, offset);
  100879:	90                   	nop
  10087a:	c9                   	leave  
  10087b:	c3                   	ret    

0010087c <nothing>:
    return 1;
};
*/
#define elf   ((struct ELFHeader *) 0x10000)

void nothing(){}
  10087c:	55                   	push   %ebp
  10087d:	89 e5                	mov    %esp,%ebp
  10087f:	90                   	nop
  100880:	5d                   	pop    %ebp
  100881:	c3                   	ret    

00100882 <nothing2>:
void nothing2(int k){}
  100882:	55                   	push   %ebp
  100883:	89 e5                	mov    %esp,%ebp
  100885:	90                   	nop
  100886:	5d                   	pop    %ebp
  100887:	c3                   	ret    

00100888 <main>:
int main(){
  100888:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  10088c:	83 e4 f0             	and    $0xfffffff0,%esp
  10088f:	ff 71 fc             	pushl  -0x4(%ecx)
  100892:	55                   	push   %ebp
  100893:	89 e5                	mov    %esp,%ebp
  100895:	51                   	push   %ecx
  100896:	83 ec 14             	sub    $0x14,%esp
	init_serial();
  100899:	e8 73 fc ff ff       	call   100511 <init_serial>
	init_timer();
  10089e:	e8 0f fe ff ff       	call   1006b2 <init_timer>
	init_idt();
  1008a3:	e8 f8 f9 ff ff       	call   1002a0 <init_idt>
	init_intr();
  1008a8:	e8 f2 fc ff ff       	call   10059f <init_intr>
	set_keyboard_intr_handler(nothing2);
  1008ad:	83 ec 0c             	sub    $0xc,%esp
  1008b0:	68 82 08 10 00       	push   $0x100882
  1008b5:	e8 b0 f7 ff ff       	call   10006a <set_keyboard_intr_handler>
  1008ba:	83 c4 10             	add    $0x10,%esp
	set_timer_intr_handler(nothing);
  1008bd:	83 ec 0c             	sub    $0xc,%esp
  1008c0:	68 7c 08 10 00       	push   $0x10087c
  1008c5:	e8 92 f7 ff ff       	call   10005c <set_timer_intr_handler>
  1008ca:	83 c4 10             	add    $0x10,%esp


  struct ProgramHeader *ph, *eph;
  unsigned char* pa, *i;

  readseg((unsigned char*)elf, 8*SECTSIZE, 102400);
  1008cd:	83 ec 04             	sub    $0x4,%esp
  1008d0:	68 00 90 01 00       	push   $0x19000
  1008d5:	68 00 10 00 00       	push   $0x1000
  1008da:	68 00 00 01 00       	push   $0x10000
  1008df:	e8 35 ff ff ff       	call   100819 <readseg>
  1008e4:	83 c4 10             	add    $0x10,%esp

  printf("Magic Assertion: %x\n", (elf->magic == 0x464C457FU));
  1008e7:	b8 00 00 01 00       	mov    $0x10000,%eax
  1008ec:	8b 00                	mov    (%eax),%eax
  1008ee:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  1008f3:	0f 94 c0             	sete   %al
  1008f6:	0f b6 c0             	movzbl %al,%eax
  1008f9:	83 ec 08             	sub    $0x8,%esp
  1008fc:	50                   	push   %eax
  1008fd:	68 64 19 10 00       	push   $0x101964
  100902:	e8 a7 04 00 00       	call   100dae <printf>
  100907:	83 c4 10             	add    $0x10,%esp


  ph = (struct ProgramHeader*)((char *)elf + elf->phoff);
  10090a:	b8 00 00 01 00       	mov    $0x10000,%eax
  10090f:	8b 40 1c             	mov    0x1c(%eax),%eax
  100912:	05 00 00 01 00       	add    $0x10000,%eax
  100917:	89 45 f4             	mov    %eax,-0xc(%ebp)
  eph = ph + elf->phnum;
  10091a:	b8 00 00 01 00       	mov    $0x10000,%eax
  10091f:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  100923:	0f b7 c0             	movzwl %ax,%eax
  100926:	c1 e0 05             	shl    $0x5,%eax
  100929:	89 c2                	mov    %eax,%edx
  10092b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10092e:	01 d0                	add    %edx,%eax
  100930:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(; ph < eph; ph ++) {
  100933:	eb 5c                	jmp    100991 <main+0x109>
    pa = (unsigned char*)ph->paddr; 
  100935:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100938:	8b 40 0c             	mov    0xc(%eax),%eax
  10093b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    readseg(pa, ph->filesz, 102400+ph->off); 
  10093e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100941:	8b 40 04             	mov    0x4(%eax),%eax
  100944:	05 00 90 01 00       	add    $0x19000,%eax
  100949:	89 c2                	mov    %eax,%edx
  10094b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10094e:	8b 40 10             	mov    0x10(%eax),%eax
  100951:	83 ec 04             	sub    $0x4,%esp
  100954:	52                   	push   %edx
  100955:	50                   	push   %eax
  100956:	ff 75 e8             	pushl  -0x18(%ebp)
  100959:	e8 bb fe ff ff       	call   100819 <readseg>
  10095e:	83 c4 10             	add    $0x10,%esp
    for (i = pa + ph->filesz; i < pa + ph->memsz; *i ++ = 0);
  100961:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100964:	8b 50 10             	mov    0x10(%eax),%edx
  100967:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10096a:	01 d0                	add    %edx,%eax
  10096c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10096f:	eb 0c                	jmp    10097d <main+0xf5>
  100971:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100974:	8d 50 01             	lea    0x1(%eax),%edx
  100977:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10097a:	c6 00 00             	movb   $0x0,(%eax)
  10097d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100980:	8b 50 14             	mov    0x14(%eax),%edx
  100983:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100986:	01 d0                	add    %edx,%eax
  100988:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10098b:	77 e4                	ja     100971 <main+0xe9>
  printf("Magic Assertion: %x\n", (elf->magic == 0x464C457FU));


  ph = (struct ProgramHeader*)((char *)elf + elf->phoff);
  eph = ph + elf->phnum;
  for(; ph < eph; ph ++) {
  10098d:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
  100991:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100994:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  100997:	72 9c                	jb     100935 <main+0xad>
    pa = (unsigned char*)ph->paddr; 
    readseg(pa, ph->filesz, 102400+ph->off); 
    for (i = pa + ph->filesz; i < pa + ph->memsz; *i ++ = 0);
  }

  printf("THe\n");
  100999:	83 ec 0c             	sub    $0xc,%esp
  10099c:	68 79 19 10 00       	push   $0x101979
  1009a1:	e8 08 04 00 00       	call   100dae <printf>
  1009a6:	83 c4 10             	add    $0x10,%esp
  enable_interrupt();
  1009a9:	e8 5c fb ff ff       	call   10050a <enable_interrupt>
  printf("%x\n",elf->entry);
  1009ae:	b8 00 00 01 00       	mov    $0x10000,%eax
  1009b3:	8b 40 18             	mov    0x18(%eax),%eax
  1009b6:	83 ec 08             	sub    $0x8,%esp
  1009b9:	50                   	push   %eax
  1009ba:	68 7e 19 10 00       	push   $0x10197e
  1009bf:	e8 ea 03 00 00       	call   100dae <printf>
  1009c4:	83 c4 10             	add    $0x10,%esp
  ((void(*)(void))elf->entry)();
  1009c7:	b8 00 00 01 00       	mov    $0x10000,%eax
  1009cc:	8b 40 18             	mov    0x18(%eax),%eax
  1009cf:	ff d0                	call   *%eax
  printf("%s\n", "Never return otherwise you are fucked!");
  1009d1:	83 ec 08             	sub    $0x8,%esp
  1009d4:	68 84 19 10 00       	push   $0x101984
  1009d9:	68 ab 19 10 00       	push   $0x1019ab
  1009de:	e8 cb 03 00 00       	call   100dae <printf>
  1009e3:	83 c4 10             	add    $0x10,%esp
  while(1){
  }
  1009e6:	eb fe                	jmp    1009e6 <main+0x15e>

001009e8 <vec0>:
# 中断和异常处理函数的入口
# 中断处理函数会在IDT中为相应的中断/异常设置处理程序
# 中断/异常的行为参见i386手册
.globl vec0; vec0:pushl $0;  pushl $0; jmp asm_do_irq
  1009e8:	6a 00                	push   $0x0
  1009ea:	6a 00                	push   $0x0
  1009ec:	eb 76                	jmp    100a64 <asm_do_irq>

001009ee <vec1>:
.globl vec1; vec1: pushl $0;pushl $1; jmp asm_do_irq
  1009ee:	6a 00                	push   $0x0
  1009f0:	6a 01                	push   $0x1
  1009f2:	eb 70                	jmp    100a64 <asm_do_irq>

001009f4 <vec2>:
.globl vec2; vec2: pushl $0;pushl $2; jmp asm_do_irq
  1009f4:	6a 00                	push   $0x0
  1009f6:	6a 02                	push   $0x2
  1009f8:	eb 6a                	jmp    100a64 <asm_do_irq>

001009fa <vec3>:
.globl vec3; vec3: pushl $0;pushl $3; jmp asm_do_irq
  1009fa:	6a 00                	push   $0x0
  1009fc:	6a 03                	push   $0x3
  1009fe:	eb 64                	jmp    100a64 <asm_do_irq>

00100a00 <vec4>:
.globl vec4; vec4:pushl $0; pushl $4; jmp asm_do_irq
  100a00:	6a 00                	push   $0x0
  100a02:	6a 04                	push   $0x4
  100a04:	eb 5e                	jmp    100a64 <asm_do_irq>

00100a06 <vec5>:
.globl vec5; vec5:pushl $0; pushl $5; jmp asm_do_irq
  100a06:	6a 00                	push   $0x0
  100a08:	6a 05                	push   $0x5
  100a0a:	eb 58                	jmp    100a64 <asm_do_irq>

00100a0c <vec6>:
.globl vec6; vec6:pushl $0; pushl $6; jmp asm_do_irq
  100a0c:	6a 00                	push   $0x0
  100a0e:	6a 06                	push   $0x6
  100a10:	eb 52                	jmp    100a64 <asm_do_irq>

00100a12 <vec7>:
.globl vec7; vec7:pushl $0; pushl $7; jmp asm_do_irq
  100a12:	6a 00                	push   $0x0
  100a14:	6a 07                	push   $0x7
  100a16:	eb 4c                	jmp    100a64 <asm_do_irq>

00100a18 <vec8>:
.globl vec8; vec8:pushl $0; pushl $8; jmp asm_do_irq
  100a18:	6a 00                	push   $0x0
  100a1a:	6a 08                	push   $0x8
  100a1c:	eb 46                	jmp    100a64 <asm_do_irq>

00100a1e <vec9>:
.globl vec9; vec9:pushl $0; pushl $9; jmp asm_do_irq
  100a1e:	6a 00                	push   $0x0
  100a20:	6a 09                	push   $0x9
  100a22:	eb 40                	jmp    100a64 <asm_do_irq>

00100a24 <vec10>:
.globl vec10; vec10:pushl $0; pushl $10; jmp asm_do_irq
  100a24:	6a 00                	push   $0x0
  100a26:	6a 0a                	push   $0xa
  100a28:	eb 3a                	jmp    100a64 <asm_do_irq>

00100a2a <vec11>:
.globl vec11; vec11:pushl $0; pushl $11; jmp asm_do_irq
  100a2a:	6a 00                	push   $0x0
  100a2c:	6a 0b                	push   $0xb
  100a2e:	eb 34                	jmp    100a64 <asm_do_irq>

00100a30 <vec12>:
.globl vec12; vec12:pushl $0; pushl $12; jmp asm_do_irq
  100a30:	6a 00                	push   $0x0
  100a32:	6a 0c                	push   $0xc
  100a34:	eb 2e                	jmp    100a64 <asm_do_irq>

00100a36 <vec13>:
.globl vec13; vec13:pushl $0; pushl $13; jmp asm_do_irq
  100a36:	6a 00                	push   $0x0
  100a38:	6a 0d                	push   $0xd
  100a3a:	eb 28                	jmp    100a64 <asm_do_irq>

00100a3c <vecsys>:

.globl vecsys; vecsys:  pushl $0;  pushl $0x80; jmp asm_do_irq
  100a3c:	6a 00                	push   $0x0
  100a3e:	68 80 00 00 00       	push   $0x80
  100a43:	eb 1f                	jmp    100a64 <asm_do_irq>

00100a45 <irq0>:

.globl irq0; irq0:pushl $0; pushl $1000; jmp asm_do_irq
  100a45:	6a 00                	push   $0x0
  100a47:	68 e8 03 00 00       	push   $0x3e8
  100a4c:	eb 16                	jmp    100a64 <asm_do_irq>

00100a4e <irq1>:
.globl irq1; irq1:pushl $0; pushl $1001; jmp asm_do_irq
  100a4e:	6a 00                	push   $0x0
  100a50:	68 e9 03 00 00       	push   $0x3e9
  100a55:	eb 0d                	jmp    100a64 <asm_do_irq>

00100a57 <irq14>:
.globl irq14; irq14: pushl $0;pushl $1014; jmp asm_do_irq
  100a57:	6a 00                	push   $0x0
  100a59:	68 f6 03 00 00       	push   $0x3f6
  100a5e:	eb 04                	jmp    100a64 <asm_do_irq>

00100a60 <irq_empty>:

.globl irq_empty; irq_empty: pushl $-1; jmp asm_do_irq
  100a60:	6a ff                	push   $0xffffffff
  100a62:	eb 00                	jmp    100a64 <asm_do_irq>

00100a64 <asm_do_irq>:

# ！调用C编写的中断处理程序(见irq/irq_handle.c)！
.globl asm_do_irq
.extern irq_handle
asm_do_irq:
	cli
  100a64:	fa                   	cli    
	pushal
  100a65:	60                   	pusha  

	pushl %esp			# ???
  100a66:	54                   	push   %esp
	call irq_handle
  100a67:	e8 0c f6 ff ff       	call   100078 <irq_handle>
	addl $4, %esp
  100a6c:	83 c4 04             	add    $0x4,%esp

	popal
  100a6f:	61                   	popa   
	addl $8, %esp
  100a70:	83 c4 08             	add    $0x8,%esp
	#sti
	iret
  100a73:	cf                   	iret   

00100a74 <serial_idle>:

static inline
int serial_idle(void) {
  100a74:	55                   	push   %ebp
  100a75:	89 e5                	mov    %esp,%ebp
  100a77:	83 ec 10             	sub    $0x10,%esp
  100a7a:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  100a81:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100a84:	89 c2                	mov    %eax,%edx
  100a86:	ec                   	in     (%dx),%al
  100a87:	88 45 fb             	mov    %al,-0x5(%ebp)
	return data;
  100a8a:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
	return (inb(SERIAL_PORT + 5) & 0x20) != 0;
  100a8e:	0f b6 c0             	movzbl %al,%eax
  100a91:	83 e0 20             	and    $0x20,%eax
  100a94:	85 c0                	test   %eax,%eax
  100a96:	0f 95 c0             	setne  %al
  100a99:	0f b6 c0             	movzbl %al,%eax
}
  100a9c:	c9                   	leave  
  100a9d:	c3                   	ret    

00100a9e <serial_printc>:

static inline
void serial_printc(char ch) {
  100a9e:	55                   	push   %ebp
  100a9f:	89 e5                	mov    %esp,%ebp
  100aa1:	83 ec 14             	sub    $0x14,%esp
  100aa4:	8b 45 08             	mov    0x8(%ebp),%eax
  100aa7:	88 45 ec             	mov    %al,-0x14(%ebp)
	while (!serial_idle());
  100aaa:	90                   	nop
  100aab:	e8 c4 ff ff ff       	call   100a74 <serial_idle>
  100ab0:	85 c0                	test   %eax,%eax
  100ab2:	74 f7                	je     100aab <serial_printc+0xd>
	outb(SERIAL_PORT, ch);
  100ab4:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  100ab8:	0f b6 c0             	movzbl %al,%eax
  100abb:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)
  100ac2:	88 45 fb             	mov    %al,-0x5(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  100ac5:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  100ac9:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100acc:	ee                   	out    %al,(%dx)
}
  100acd:	90                   	nop
  100ace:	c9                   	leave  
  100acf:	c3                   	ret    

00100ad0 <printp>:
enum{
	NONE,
	READ
};
#define cur (*str)
void printp(void (*printer)(char), const char *ctl){
  100ad0:	55                   	push   %ebp
  100ad1:	89 e5                	mov    %esp,%ebp
  100ad3:	83 ec 18             	sub    $0x18,%esp
	const char *str = ctl;
  100ad6:	8b 45 0c             	mov    0xc(%ebp),%eax
  100ad9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;cur!='\0';str++){
  100adc:	eb 19                	jmp    100af7 <printp+0x27>
		printer(cur);
  100ade:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ae1:	0f b6 00             	movzbl (%eax),%eax
  100ae4:	0f be c0             	movsbl %al,%eax
  100ae7:	83 ec 0c             	sub    $0xc,%esp
  100aea:	50                   	push   %eax
  100aeb:	8b 45 08             	mov    0x8(%ebp),%eax
  100aee:	ff d0                	call   *%eax
  100af0:	83 c4 10             	add    $0x10,%esp
	READ
};
#define cur (*str)
void printp(void (*printer)(char), const char *ctl){
	const char *str = ctl;
	for(;cur!='\0';str++){
  100af3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100afa:	0f b6 00             	movzbl (%eax),%eax
  100afd:	84 c0                	test   %al,%al
  100aff:	75 dd                	jne    100ade <printp+0xe>
		printer(cur);
	}
}
  100b01:	90                   	nop
  100b02:	c9                   	leave  
  100b03:	c3                   	ret    

00100b04 <vfprintf>:
void vfprintf(void (*printer)(char), const char *ctl, void **args) {
  100b04:	55                   	push   %ebp
  100b05:	89 e5                	mov    %esp,%ebp
  100b07:	81 ec 98 00 00 00    	sub    $0x98,%esp
	const char *str = ctl;
  100b0d:	8b 45 0c             	mov    0xc(%ebp),%eax
  100b10:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32_t i = 0;
  100b13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int32_t type = NONE;
  100b1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	void** pointer = args;
  100b21:	8b 45 10             	mov    0x10(%ebp),%eax
  100b24:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(;*str != '\0'; str ++){
  100b27:	e9 71 02 00 00       	jmp    100d9d <vfprintf+0x299>
		if(cur == '%'){
  100b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b2f:	0f b6 00             	movzbl (%eax),%eax
  100b32:	3c 25                	cmp    $0x25,%al
  100b34:	75 0c                	jne    100b42 <vfprintf+0x3e>
			type = READ;
  100b36:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			continue;
  100b3d:	e9 57 02 00 00       	jmp    100d99 <vfprintf+0x295>
		}
		if(type == READ){
  100b42:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
  100b46:	0f 85 32 02 00 00    	jne    100d7e <vfprintf+0x27a>
			if(cur == 's'){
  100b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b4f:	0f b6 00             	movzbl (%eax),%eax
  100b52:	3c 73                	cmp    $0x73,%al
  100b54:	75 35                	jne    100b8b <vfprintf+0x87>
				char* p= XGET(pointer, char*);
  100b56:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100b59:	8b 00                	mov    (%eax),%eax
  100b5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				for(; *p != '\0';p++){
  100b5e:	eb 19                	jmp    100b79 <vfprintf+0x75>
					printer(*p);
  100b60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100b63:	0f b6 00             	movzbl (%eax),%eax
  100b66:	0f be c0             	movsbl %al,%eax
  100b69:	83 ec 0c             	sub    $0xc,%esp
  100b6c:	50                   	push   %eax
  100b6d:	8b 45 08             	mov    0x8(%ebp),%eax
  100b70:	ff d0                	call   *%eax
  100b72:	83 c4 10             	add    $0x10,%esp
			continue;
		}
		if(type == READ){
			if(cur == 's'){
				char* p= XGET(pointer, char*);
				for(; *p != '\0';p++){
  100b75:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  100b79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100b7c:	0f b6 00             	movzbl (%eax),%eax
  100b7f:	84 c0                	test   %al,%al
  100b81:	75 dd                	jne    100b60 <vfprintf+0x5c>
					printer(*p);
				}
				XNEXT(pointer);
  100b83:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
				i++;
  100b87:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
			}
			if(cur == 'x'){
  100b8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b8e:	0f b6 00             	movzbl (%eax),%eax
  100b91:	3c 78                	cmp    $0x78,%al
  100b93:	0f 85 9f 00 00 00    	jne    100c38 <vfprintf+0x134>
				uint32_t x = XGET(pointer, int);
  100b99:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100b9c:	8b 00                	mov    (%eax),%eax
  100b9e:	89 45 e0             	mov    %eax,-0x20(%ebp)
				if(x==0){
  100ba1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  100ba5:	75 1d                	jne    100bc4 <vfprintf+0xc0>
					printer('0');
  100ba7:	83 ec 0c             	sub    $0xc,%esp
  100baa:	6a 30                	push   $0x30
  100bac:	8b 45 08             	mov    0x8(%ebp),%eax
  100baf:	ff d0                	call   *%eax
  100bb1:	83 c4 10             	add    $0x10,%esp
					XNEXT(pointer);
  100bb4:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
					type = NONE;
  100bb8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  100bbf:	e9 d5 01 00 00       	jmp    100d99 <vfprintf+0x295>
					continue;
				}
				char digits[100];
				int di=0;
  100bc4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				while(x>=1){
  100bcb:	eb 30                	jmp    100bfd <vfprintf+0xf9>
					int d=(x%16);
  100bcd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100bd0:	83 e0 0f             	and    $0xf,%eax
  100bd3:	89 45 d8             	mov    %eax,-0x28(%ebp)
					if(d>=10){
  100bd6:	83 7d d8 09          	cmpl   $0x9,-0x28(%ebp)
  100bda:	7e 04                	jle    100be0 <vfprintf+0xdc>
						d+='a'-'0'-10;
  100bdc:	83 45 d8 27          	addl   $0x27,-0x28(%ebp)
					}
					digits[di] = '0'+d;
  100be0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100be3:	83 c0 30             	add    $0x30,%eax
  100be6:	89 c1                	mov    %eax,%ecx
  100be8:	8d 95 6c ff ff ff    	lea    -0x94(%ebp),%edx
  100bee:	8b 45 dc             	mov    -0x24(%ebp),%eax
  100bf1:	01 d0                	add    %edx,%eax
  100bf3:	88 08                	mov    %cl,(%eax)
					x>>=4;
  100bf5:	c1 6d e0 04          	shrl   $0x4,-0x20(%ebp)
					di ++;
  100bf9:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
					type = NONE;
					continue;
				}
				char digits[100];
				int di=0;
				while(x>=1){
  100bfd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  100c01:	75 ca                	jne    100bcd <vfprintf+0xc9>
					}
					digits[di] = '0'+d;
					x>>=4;
					di ++;
				};
				di--;
  100c03:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
				for(;di>=0;di--){
  100c07:	eb 21                	jmp    100c2a <vfprintf+0x126>
					printer(digits[di]);
  100c09:	8d 95 6c ff ff ff    	lea    -0x94(%ebp),%edx
  100c0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  100c12:	01 d0                	add    %edx,%eax
  100c14:	0f b6 00             	movzbl (%eax),%eax
  100c17:	0f be c0             	movsbl %al,%eax
  100c1a:	83 ec 0c             	sub    $0xc,%esp
  100c1d:	50                   	push   %eax
  100c1e:	8b 45 08             	mov    0x8(%ebp),%eax
  100c21:	ff d0                	call   *%eax
  100c23:	83 c4 10             	add    $0x10,%esp
					digits[di] = '0'+d;
					x>>=4;
					di ++;
				};
				di--;
				for(;di>=0;di--){
  100c26:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
  100c2a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  100c2e:	79 d9                	jns    100c09 <vfprintf+0x105>
					printer(digits[di]);
				}
				XNEXT(pointer);
  100c30:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
				i++;
  100c34:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
			}
			if(cur == 'd'){
  100c38:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100c3b:	0f b6 00             	movzbl (%eax),%eax
  100c3e:	3c 64                	cmp    $0x64,%al
  100c40:	0f 85 08 01 00 00    	jne    100d4e <vfprintf+0x24a>
				int x = XGET(pointer, int);
  100c46:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100c49:	8b 00                	mov    (%eax),%eax
  100c4b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				if(x==-2147483648){
  100c4e:	81 7d d4 00 00 00 80 	cmpl   $0x80000000,-0x2c(%ebp)
  100c55:	75 23                	jne    100c7a <vfprintf+0x176>
					printp(printer, "-2147483648");
  100c57:	83 ec 08             	sub    $0x8,%esp
  100c5a:	68 af 19 10 00       	push   $0x1019af
  100c5f:	ff 75 08             	pushl  0x8(%ebp)
  100c62:	e8 69 fe ff ff       	call   100ad0 <printp>
  100c67:	83 c4 10             	add    $0x10,%esp
					XNEXT(pointer);
  100c6a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
					type = NONE;
  100c6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
					continue;
  100c75:	e9 1f 01 00 00       	jmp    100d99 <vfprintf+0x295>
				}
				if(x==0){
  100c7a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  100c7e:	75 1e                	jne    100c9e <vfprintf+0x19a>
					printer('0');
  100c80:	83 ec 0c             	sub    $0xc,%esp
  100c83:	6a 30                	push   $0x30
  100c85:	8b 45 08             	mov    0x8(%ebp),%eax
  100c88:	ff d0                	call   *%eax
  100c8a:	83 c4 10             	add    $0x10,%esp
					XNEXT(pointer);
  100c8d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
					type = NONE;
  100c91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
					continue;
  100c98:	90                   	nop
  100c99:	e9 fb 00 00 00       	jmp    100d99 <vfprintf+0x295>
				}
				if(x<0){
  100c9e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  100ca2:	79 10                	jns    100cb4 <vfprintf+0x1b0>
					printer('-');
  100ca4:	83 ec 0c             	sub    $0xc,%esp
  100ca7:	6a 2d                	push   $0x2d
  100ca9:	8b 45 08             	mov    0x8(%ebp),%eax
  100cac:	ff d0                	call   *%eax
  100cae:	83 c4 10             	add    $0x10,%esp
					x=-x;
  100cb1:	f7 5d d4             	negl   -0x2c(%ebp)
				}
				char digits[100];
				int di=0;
  100cb4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
				while(x>=1){
  100cbb:	eb 56                	jmp    100d13 <vfprintf+0x20f>
					digits[di] = '0'+(x%10);
  100cbd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  100cc0:	ba 67 66 66 66       	mov    $0x66666667,%edx
  100cc5:	89 c8                	mov    %ecx,%eax
  100cc7:	f7 ea                	imul   %edx
  100cc9:	c1 fa 02             	sar    $0x2,%edx
  100ccc:	89 c8                	mov    %ecx,%eax
  100cce:	c1 f8 1f             	sar    $0x1f,%eax
  100cd1:	29 c2                	sub    %eax,%edx
  100cd3:	89 d0                	mov    %edx,%eax
  100cd5:	c1 e0 02             	shl    $0x2,%eax
  100cd8:	01 d0                	add    %edx,%eax
  100cda:	01 c0                	add    %eax,%eax
  100cdc:	29 c1                	sub    %eax,%ecx
  100cde:	89 ca                	mov    %ecx,%edx
  100ce0:	89 d0                	mov    %edx,%eax
  100ce2:	83 c0 30             	add    $0x30,%eax
  100ce5:	89 c1                	mov    %eax,%ecx
  100ce7:	8d 95 6c ff ff ff    	lea    -0x94(%ebp),%edx
  100ced:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100cf0:	01 d0                	add    %edx,%eax
  100cf2:	88 08                	mov    %cl,(%eax)
					x/=10;
  100cf4:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  100cf7:	ba 67 66 66 66       	mov    $0x66666667,%edx
  100cfc:	89 c8                	mov    %ecx,%eax
  100cfe:	f7 ea                	imul   %edx
  100d00:	c1 fa 02             	sar    $0x2,%edx
  100d03:	89 c8                	mov    %ecx,%eax
  100d05:	c1 f8 1f             	sar    $0x1f,%eax
  100d08:	29 c2                	sub    %eax,%edx
  100d0a:	89 d0                	mov    %edx,%eax
  100d0c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
					di++;
  100d0f:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
					printer('-');
					x=-x;
				}
				char digits[100];
				int di=0;
				while(x>=1){
  100d13:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  100d17:	7f a4                	jg     100cbd <vfprintf+0x1b9>
					digits[di] = '0'+(x%10);
					x/=10;
					di++;
				};
				di--;
  100d19:	83 6d d0 01          	subl   $0x1,-0x30(%ebp)
				for(;di>=0;di--){
  100d1d:	eb 21                	jmp    100d40 <vfprintf+0x23c>
					printer(digits[di]);
  100d1f:	8d 95 6c ff ff ff    	lea    -0x94(%ebp),%edx
  100d25:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100d28:	01 d0                	add    %edx,%eax
  100d2a:	0f b6 00             	movzbl (%eax),%eax
  100d2d:	0f be c0             	movsbl %al,%eax
  100d30:	83 ec 0c             	sub    $0xc,%esp
  100d33:	50                   	push   %eax
  100d34:	8b 45 08             	mov    0x8(%ebp),%eax
  100d37:	ff d0                	call   *%eax
  100d39:	83 c4 10             	add    $0x10,%esp
					digits[di] = '0'+(x%10);
					x/=10;
					di++;
				};
				di--;
				for(;di>=0;di--){
  100d3c:	83 6d d0 01          	subl   $0x1,-0x30(%ebp)
  100d40:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  100d44:	79 d9                	jns    100d1f <vfprintf+0x21b>
					printer(digits[di]);
				}
				XNEXT(pointer);
  100d46:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
				i++;
  100d4a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
			}
			if(cur == 'c'){
  100d4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100d51:	0f b6 00             	movzbl (%eax),%eax
  100d54:	3c 63                	cmp    $0x63,%al
  100d56:	75 1d                	jne    100d75 <vfprintf+0x271>
				//char* pointer = (char*)args;
				//printer(*pointer);
				printer(XGET(pointer, char));
  100d58:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100d5b:	0f b6 00             	movzbl (%eax),%eax
  100d5e:	0f be c0             	movsbl %al,%eax
  100d61:	83 ec 0c             	sub    $0xc,%esp
  100d64:	50                   	push   %eax
  100d65:	8b 45 08             	mov    0x8(%ebp),%eax
  100d68:	ff d0                	call   *%eax
  100d6a:	83 c4 10             	add    $0x10,%esp
				XNEXT(pointer);
  100d6d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
				i++;
  100d71:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
			}
			type = NONE;
  100d75:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			continue;
  100d7c:	eb 1b                	jmp    100d99 <vfprintf+0x295>
		}
		if(type == NONE){
  100d7e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  100d82:	75 15                	jne    100d99 <vfprintf+0x295>
			printer(cur);
  100d84:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100d87:	0f b6 00             	movzbl (%eax),%eax
  100d8a:	0f be c0             	movsbl %al,%eax
  100d8d:	83 ec 0c             	sub    $0xc,%esp
  100d90:	50                   	push   %eax
  100d91:	8b 45 08             	mov    0x8(%ebp),%eax
  100d94:	ff d0                	call   *%eax
  100d96:	83 c4 10             	add    $0x10,%esp
void vfprintf(void (*printer)(char), const char *ctl, void **args) {
	const char *str = ctl;
	int32_t i = 0;
	int32_t type = NONE;
	void** pointer = args;
	for(;*str != '\0'; str ++){
  100d99:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100da0:	0f b6 00             	movzbl (%eax),%eax
  100da3:	84 c0                	test   %al,%al
  100da5:	0f 85 81 fd ff ff    	jne    100b2c <vfprintf+0x28>
		if(type == NONE){
			printer(cur);
		}
		//last = cur;
	}
}
  100dab:	90                   	nop
  100dac:	c9                   	leave  
  100dad:	c3                   	ret    

00100dae <printf>:

void __attribute__((__noinline__)) 
printf(const char *ctl, ...) {
  100dae:	55                   	push   %ebp
  100daf:	89 e5                	mov    %esp,%ebp
  100db1:	83 ec 18             	sub    $0x18,%esp
	void **args = (void **)&ctl + 1;
  100db4:	8d 45 0c             	lea    0xc(%ebp),%eax
  100db7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vfprintf(serial_printc, ctl, args);
  100dba:	8b 45 08             	mov    0x8(%ebp),%eax
  100dbd:	83 ec 04             	sub    $0x4,%esp
  100dc0:	ff 75 f4             	pushl  -0xc(%ebp)
  100dc3:	50                   	push   %eax
  100dc4:	68 9e 0a 10 00       	push   $0x100a9e
  100dc9:	e8 36 fd ff ff       	call   100b04 <vfprintf>
  100dce:	83 c4 10             	add    $0x10,%esp
}
  100dd1:	90                   	nop
  100dd2:	c9                   	leave  
  100dd3:	c3                   	ret    

00100dd4 <drawFrame>:
int gameState=0;
uint8_t Frame[320*200];
int x,y;
int num=0;
uint8_t* VGAP=(uint8_t*)0xa0000;
void drawFrame(){
  100dd4:	55                   	push   %ebp
  100dd5:	89 e5                	mov    %esp,%ebp
  100dd7:	83 ec 08             	sub    $0x8,%esp
    memcpy(VGAP,Frame,VGA_SIZ);
  100dda:	a1 04 30 10 00       	mov    0x103004,%eax
  100ddf:	83 ec 04             	sub    $0x4,%esp
  100de2:	68 00 fa 00 00       	push   $0xfa00
  100de7:	68 60 39 10 00       	push   $0x103960
  100dec:	50                   	push   %eax
  100ded:	e8 ee 06 00 00       	call   1014e0 <memcpy>
  100df2:	83 c4 10             	add    $0x10,%esp
}
  100df5:	90                   	nop
  100df6:	c9                   	leave  
  100df7:	c3                   	ret    

00100df8 <drawBlock>:

uint8_t K[10];

void drawBlock(int x,int y,uint8_t color){
  100df8:	55                   	push   %ebp
  100df9:	89 e5                	mov    %esp,%ebp
  100dfb:	83 ec 28             	sub    $0x28,%esp
  100dfe:	8b 45 10             	mov    0x10(%ebp),%eax
  100e01:	88 45 e4             	mov    %al,-0x1c(%ebp)
    for(int i=0;i<10;i++){
  100e04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  100e0b:	eb 13                	jmp    100e20 <drawBlock+0x28>
        K[i]=color;
  100e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100e10:	8d 90 60 33 11 00    	lea    0x113360(%eax),%edx
  100e16:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  100e1a:	88 02                	mov    %al,(%edx)
}

uint8_t K[10];

void drawBlock(int x,int y,uint8_t color){
    for(int i=0;i<10;i++){
  100e1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100e20:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
  100e24:	7e e7                	jle    100e0d <drawBlock+0x15>
        K[i]=color;
    }
    for(int i=0;i<10;i++){
  100e26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100e2d:	eb 35                	jmp    100e64 <drawBlock+0x6c>
        memcpy((Frame+(x+i)*320+y),K,10);
  100e2f:	8b 55 08             	mov    0x8(%ebp),%edx
  100e32:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100e35:	01 c2                	add    %eax,%edx
  100e37:	89 d0                	mov    %edx,%eax
  100e39:	c1 e0 02             	shl    $0x2,%eax
  100e3c:	01 d0                	add    %edx,%eax
  100e3e:	c1 e0 06             	shl    $0x6,%eax
  100e41:	89 c2                	mov    %eax,%edx
  100e43:	8b 45 0c             	mov    0xc(%ebp),%eax
  100e46:	01 d0                	add    %edx,%eax
  100e48:	05 60 39 10 00       	add    $0x103960,%eax
  100e4d:	83 ec 04             	sub    $0x4,%esp
  100e50:	6a 0a                	push   $0xa
  100e52:	68 60 33 11 00       	push   $0x113360
  100e57:	50                   	push   %eax
  100e58:	e8 83 06 00 00       	call   1014e0 <memcpy>
  100e5d:	83 c4 10             	add    $0x10,%esp

void drawBlock(int x,int y,uint8_t color){
    for(int i=0;i<10;i++){
        K[i]=color;
    }
    for(int i=0;i<10;i++){
  100e60:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  100e64:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
  100e68:	7e c5                	jle    100e2f <drawBlock+0x37>
        memcpy((Frame+(x+i)*320+y),K,10);
    }
}
  100e6a:	90                   	nop
  100e6b:	c9                   	leave  
  100e6c:	c3                   	ret    

00100e6d <get_gameState>:

int get_gameState(){
  100e6d:	55                   	push   %ebp
  100e6e:	89 e5                	mov    %esp,%ebp
    return gameState;
  100e70:	a1 b0 30 10 00       	mov    0x1030b0,%eax
}
  100e75:	5d                   	pop    %ebp
  100e76:	c3                   	ret    

00100e77 <initVideo>:

void initVideo(uint8_t color){
  100e77:	55                   	push   %ebp
  100e78:	89 e5                	mov    %esp,%ebp
  100e7a:	83 ec 28             	sub    $0x28,%esp
  100e7d:	8b 45 08             	mov    0x8(%ebp),%eax
  100e80:	88 45 e4             	mov    %al,-0x1c(%ebp)
    for(int i=0;i<VGA_SIZ;i++){
  100e83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  100e8a:	eb 12                	jmp    100e9e <initVideo+0x27>
        VGAP[i]=0xFF;
  100e8c:	8b 15 04 30 10 00    	mov    0x103004,%edx
  100e92:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100e95:	01 d0                	add    %edx,%eax
  100e97:	c6 00 ff             	movb   $0xff,(%eax)
int get_gameState(){
    return gameState;
}

void initVideo(uint8_t color){
    for(int i=0;i<VGA_SIZ;i++){
  100e9a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100e9e:	81 7d f4 ff f9 00 00 	cmpl   $0xf9ff,-0xc(%ebp)
  100ea5:	7e e5                	jle    100e8c <initVideo+0x15>
        VGAP[i]=0xFF;
    }
    gameState=1;
  100ea7:	c7 05 b0 30 10 00 01 	movl   $0x1,0x1030b0
  100eae:	00 00 00 
    x=190;
  100eb1:	c7 05 40 39 10 00 be 	movl   $0xbe,0x103940
  100eb8:	00 00 00 
    y=150;
  100ebb:	c7 05 6c 33 11 00 96 	movl   $0x96,0x11336c
  100ec2:	00 00 00 
    for(int i=0;i<10;i++){
  100ec5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100ecc:	eb 13                	jmp    100ee1 <initVideo+0x6a>
        K[i]=color;
  100ece:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100ed1:	8d 90 60 33 11 00    	lea    0x113360(%eax),%edx
  100ed7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  100edb:	88 02                	mov    %al,(%edx)
        VGAP[i]=0xFF;
    }
    gameState=1;
    x=190;
    y=150;
    for(int i=0;i<10;i++){
  100edd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  100ee1:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
  100ee5:	7e e7                	jle    100ece <initVideo+0x57>
        K[i]=color;
    }
    init_list();
  100ee7:	e8 f9 07 00 00       	call   1016e5 <init_list>
    drawBlock(x,y,MBCOLOR);
  100eec:	8b 15 6c 33 11 00    	mov    0x11336c,%edx
  100ef2:	a1 40 39 10 00       	mov    0x103940,%eax
  100ef7:	83 ec 04             	sub    $0x4,%esp
  100efa:	6a 5f                	push   $0x5f
  100efc:	52                   	push   %edx
  100efd:	50                   	push   %eax
  100efe:	e8 f5 fe ff ff       	call   100df8 <drawBlock>
  100f03:	83 c4 10             	add    $0x10,%esp
}
  100f06:	90                   	nop
  100f07:	c9                   	leave  
  100f08:	c3                   	ret    

00100f09 <addBlock>:

void addBlock(){
  100f09:	55                   	push   %ebp
  100f0a:	89 e5                	mov    %esp,%ebp
  100f0c:	83 ec 08             	sub    $0x8,%esp
    add(0,(rand()%32)*10);
  100f0f:	e8 25 0a 00 00       	call   101939 <rand>
  100f14:	89 c2                	mov    %eax,%edx
  100f16:	89 d0                	mov    %edx,%eax
  100f18:	c1 f8 1f             	sar    $0x1f,%eax
  100f1b:	c1 e8 1b             	shr    $0x1b,%eax
  100f1e:	01 c2                	add    %eax,%edx
  100f20:	83 e2 1f             	and    $0x1f,%edx
  100f23:	29 c2                	sub    %eax,%edx
  100f25:	89 d0                	mov    %edx,%eax
  100f27:	89 c2                	mov    %eax,%edx
  100f29:	89 d0                	mov    %edx,%eax
  100f2b:	c1 e0 02             	shl    $0x2,%eax
  100f2e:	01 d0                	add    %edx,%eax
  100f30:	01 c0                	add    %eax,%eax
  100f32:	83 ec 08             	sub    $0x8,%esp
  100f35:	50                   	push   %eax
  100f36:	6a 00                	push   $0x0
  100f38:	e8 2a 08 00 00       	call   101767 <add>
  100f3d:	83 c4 10             	add    $0x10,%esp
}
  100f40:	90                   	nop
  100f41:	c9                   	leave  
  100f42:	c3                   	ret    

00100f43 <randomMove>:

void randomMove(){
  100f43:	55                   	push   %ebp
  100f44:	89 e5                	mov    %esp,%ebp
  100f46:	83 ec 18             	sub    $0x18,%esp
    NODE* head=get_head();
  100f49:	e8 05 08 00 00       	call   101753 <get_head>
  100f4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (head!=NULL){
  100f51:	e9 97 00 00 00       	jmp    100fed <randomMove+0xaa>
        if(head->x==190){
  100f56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f59:	8b 00                	mov    (%eax),%eax
  100f5b:	3d be 00 00 00       	cmp    $0xbe,%eax
  100f60:	75 30                	jne    100f92 <randomMove+0x4f>
            drawBlock(head->x, head->y, 0xFF);
  100f62:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f65:	8b 50 04             	mov    0x4(%eax),%edx
  100f68:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f6b:	8b 00                	mov    (%eax),%eax
  100f6d:	83 ec 04             	sub    $0x4,%esp
  100f70:	68 ff 00 00 00       	push   $0xff
  100f75:	52                   	push   %edx
  100f76:	50                   	push   %eax
  100f77:	e8 7c fe ff ff       	call   100df8 <drawBlock>
  100f7c:	83 c4 10             	add    $0x10,%esp
            head=del(head);
  100f7f:	83 ec 0c             	sub    $0xc,%esp
  100f82:	ff 75 f4             	pushl  -0xc(%ebp)
  100f85:	e8 8e 08 00 00       	call   101818 <del>
  100f8a:	83 c4 10             	add    $0x10,%esp
  100f8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
            continue;
  100f90:	eb 5b                	jmp    100fed <randomMove+0xaa>
        }
        else
        {
            moveBlock(&head->x, &head->y, DOWN, 0x23,1);
  100f92:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f95:	8d 50 04             	lea    0x4(%eax),%edx
  100f98:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f9b:	83 ec 0c             	sub    $0xc,%esp
  100f9e:	6a 01                	push   $0x1
  100fa0:	6a 23                	push   $0x23
  100fa2:	6a 03                	push   $0x3
  100fa4:	52                   	push   %edx
  100fa5:	50                   	push   %eax
  100fa6:	e8 4f 00 00 00       	call   100ffa <moveBlock>
  100fab:	83 c4 20             	add    $0x20,%esp
            moveBlock(&head->x, &head->y, rand() % 2 + 1, BCOLOR,1);
  100fae:	e8 86 09 00 00       	call   101939 <rand>
  100fb3:	89 c2                	mov    %eax,%edx
  100fb5:	89 d0                	mov    %edx,%eax
  100fb7:	c1 f8 1f             	sar    $0x1f,%eax
  100fba:	c1 e8 1f             	shr    $0x1f,%eax
  100fbd:	01 c2                	add    %eax,%edx
  100fbf:	83 e2 01             	and    $0x1,%edx
  100fc2:	29 c2                	sub    %eax,%edx
  100fc4:	89 d0                	mov    %edx,%eax
  100fc6:	8d 48 01             	lea    0x1(%eax),%ecx
  100fc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100fcc:	8d 50 04             	lea    0x4(%eax),%edx
  100fcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100fd2:	83 ec 0c             	sub    $0xc,%esp
  100fd5:	6a 01                	push   $0x1
  100fd7:	6a 23                	push   $0x23
  100fd9:	51                   	push   %ecx
  100fda:	52                   	push   %edx
  100fdb:	50                   	push   %eax
  100fdc:	e8 19 00 00 00       	call   100ffa <moveBlock>
  100fe1:	83 c4 20             	add    $0x20,%esp
        }
    head=head->next;
  100fe4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100fe7:	8b 40 08             	mov    0x8(%eax),%eax
  100fea:	89 45 f4             	mov    %eax,-0xc(%ebp)
    add(0,(rand()%32)*10);
}

void randomMove(){
    NODE* head=get_head();
    while (head!=NULL){
  100fed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  100ff1:	0f 85 5f ff ff ff    	jne    100f56 <randomMove+0x13>
            moveBlock(&head->x, &head->y, DOWN, 0x23,1);
            moveBlock(&head->x, &head->y, rand() % 2 + 1, BCOLOR,1);
        }
    head=head->next;
    }
}
  100ff7:	90                   	nop
  100ff8:	c9                   	leave  
  100ff9:	c3                   	ret    

00100ffa <moveBlock>:

void moveBlock(int *nx, int *ny, int direction, uint8_t color,int which)
{
  100ffa:	55                   	push   %ebp
  100ffb:	89 e5                	mov    %esp,%ebp
  100ffd:	83 ec 18             	sub    $0x18,%esp
  101000:	8b 45 14             	mov    0x14(%ebp),%eax
  101003:	88 45 f4             	mov    %al,-0xc(%ebp)
    drawBlock(*nx, *ny, 0xFF);
  101006:	8b 45 0c             	mov    0xc(%ebp),%eax
  101009:	8b 10                	mov    (%eax),%edx
  10100b:	8b 45 08             	mov    0x8(%ebp),%eax
  10100e:	8b 00                	mov    (%eax),%eax
  101010:	83 ec 04             	sub    $0x4,%esp
  101013:	68 ff 00 00 00       	push   $0xff
  101018:	52                   	push   %edx
  101019:	50                   	push   %eax
  10101a:	e8 d9 fd ff ff       	call   100df8 <drawBlock>
  10101f:	83 c4 10             	add    $0x10,%esp
    switch (direction)
  101022:	8b 45 10             	mov    0x10(%ebp),%eax
  101025:	83 f8 02             	cmp    $0x2,%eax
  101028:	74 49                	je     101073 <moveBlock+0x79>
  10102a:	83 f8 02             	cmp    $0x2,%eax
  10102d:	7f 07                	jg     101036 <moveBlock+0x3c>
  10102f:	83 f8 01             	cmp    $0x1,%eax
  101032:	74 5a                	je     10108e <moveBlock+0x94>
  101034:	eb 7a                	jmp    1010b0 <moveBlock+0xb6>
  101036:	83 f8 03             	cmp    $0x3,%eax
  101039:	74 1d                	je     101058 <moveBlock+0x5e>
  10103b:	83 f8 04             	cmp    $0x4,%eax
  10103e:	75 70                	jne    1010b0 <moveBlock+0xb6>
    {
        case UP:
            if (*nx != 0)
  101040:	8b 45 08             	mov    0x8(%ebp),%eax
  101043:	8b 00                	mov    (%eax),%eax
  101045:	85 c0                	test   %eax,%eax
  101047:	74 5d                	je     1010a6 <moveBlock+0xac>
            {
                *nx -= 10;
  101049:	8b 45 08             	mov    0x8(%ebp),%eax
  10104c:	8b 00                	mov    (%eax),%eax
  10104e:	8d 50 f6             	lea    -0xa(%eax),%edx
  101051:	8b 45 08             	mov    0x8(%ebp),%eax
  101054:	89 10                	mov    %edx,(%eax)
            }
            break;
  101056:	eb 4e                	jmp    1010a6 <moveBlock+0xac>
        case DOWN:
            if (*nx != 190)
  101058:	8b 45 08             	mov    0x8(%ebp),%eax
  10105b:	8b 00                	mov    (%eax),%eax
  10105d:	3d be 00 00 00       	cmp    $0xbe,%eax
  101062:	74 45                	je     1010a9 <moveBlock+0xaf>
            {
                *nx += 10;
  101064:	8b 45 08             	mov    0x8(%ebp),%eax
  101067:	8b 00                	mov    (%eax),%eax
  101069:	8d 50 0a             	lea    0xa(%eax),%edx
  10106c:	8b 45 08             	mov    0x8(%ebp),%eax
  10106f:	89 10                	mov    %edx,(%eax)
            }
            break;
  101071:	eb 36                	jmp    1010a9 <moveBlock+0xaf>
        case RIGHT:
            if (*ny != 310)
  101073:	8b 45 0c             	mov    0xc(%ebp),%eax
  101076:	8b 00                	mov    (%eax),%eax
  101078:	3d 36 01 00 00       	cmp    $0x136,%eax
  10107d:	74 2d                	je     1010ac <moveBlock+0xb2>
            {
                *ny += 10;
  10107f:	8b 45 0c             	mov    0xc(%ebp),%eax
  101082:	8b 00                	mov    (%eax),%eax
  101084:	8d 50 0a             	lea    0xa(%eax),%edx
  101087:	8b 45 0c             	mov    0xc(%ebp),%eax
  10108a:	89 10                	mov    %edx,(%eax)
            }
            break;
  10108c:	eb 1e                	jmp    1010ac <moveBlock+0xb2>
        case LEFT:
            if (*ny != 0)
  10108e:	8b 45 0c             	mov    0xc(%ebp),%eax
  101091:	8b 00                	mov    (%eax),%eax
  101093:	85 c0                	test   %eax,%eax
  101095:	74 18                	je     1010af <moveBlock+0xb5>
            {
                *ny -= 10;
  101097:	8b 45 0c             	mov    0xc(%ebp),%eax
  10109a:	8b 00                	mov    (%eax),%eax
  10109c:	8d 50 f6             	lea    -0xa(%eax),%edx
  10109f:	8b 45 0c             	mov    0xc(%ebp),%eax
  1010a2:	89 10                	mov    %edx,(%eax)
            }
            break;
  1010a4:	eb 09                	jmp    1010af <moveBlock+0xb5>
        case UP:
            if (*nx != 0)
            {
                *nx -= 10;
            }
            break;
  1010a6:	90                   	nop
  1010a7:	eb 07                	jmp    1010b0 <moveBlock+0xb6>
        case DOWN:
            if (*nx != 190)
            {
                *nx += 10;
            }
            break;
  1010a9:	90                   	nop
  1010aa:	eb 04                	jmp    1010b0 <moveBlock+0xb6>
        case RIGHT:
            if (*ny != 310)
            {
                *ny += 10;
            }
            break;
  1010ac:	90                   	nop
  1010ad:	eb 01                	jmp    1010b0 <moveBlock+0xb6>
        case LEFT:
            if (*ny != 0)
            {
                *ny -= 10;
            }
            break;
  1010af:	90                   	nop
    }
    if((which==1&&VGAP[(*nx)*320+*ny]==MBCOLOR)||(which==0&&VGAP[(*nx)*320+*ny]==BCOLOR)){
  1010b0:	83 7d 18 01          	cmpl   $0x1,0x18(%ebp)
  1010b4:	75 27                	jne    1010dd <moveBlock+0xe3>
  1010b6:	8b 0d 04 30 10 00    	mov    0x103004,%ecx
  1010bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1010bf:	8b 10                	mov    (%eax),%edx
  1010c1:	89 d0                	mov    %edx,%eax
  1010c3:	c1 e0 02             	shl    $0x2,%eax
  1010c6:	01 d0                	add    %edx,%eax
  1010c8:	c1 e0 06             	shl    $0x6,%eax
  1010cb:	89 c2                	mov    %eax,%edx
  1010cd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1010d0:	8b 00                	mov    (%eax),%eax
  1010d2:	01 d0                	add    %edx,%eax
  1010d4:	01 c8                	add    %ecx,%eax
  1010d6:	0f b6 00             	movzbl (%eax),%eax
  1010d9:	3c 5f                	cmp    $0x5f,%al
  1010db:	74 2d                	je     10110a <moveBlock+0x110>
  1010dd:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1010e1:	75 31                	jne    101114 <moveBlock+0x11a>
  1010e3:	8b 0d 04 30 10 00    	mov    0x103004,%ecx
  1010e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1010ec:	8b 10                	mov    (%eax),%edx
  1010ee:	89 d0                	mov    %edx,%eax
  1010f0:	c1 e0 02             	shl    $0x2,%eax
  1010f3:	01 d0                	add    %edx,%eax
  1010f5:	c1 e0 06             	shl    $0x6,%eax
  1010f8:	89 c2                	mov    %eax,%edx
  1010fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1010fd:	8b 00                	mov    (%eax),%eax
  1010ff:	01 d0                	add    %edx,%eax
  101101:	01 c8                	add    %ecx,%eax
  101103:	0f b6 00             	movzbl (%eax),%eax
  101106:	3c 23                	cmp    $0x23,%al
  101108:	75 0a                	jne    101114 <moveBlock+0x11a>
        gameState=0;
  10110a:	c7 05 b0 30 10 00 00 	movl   $0x0,0x1030b0
  101111:	00 00 00 
    }
    drawBlock(*nx, *ny, color);
  101114:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  101118:	8b 45 0c             	mov    0xc(%ebp),%eax
  10111b:	8b 10                	mov    (%eax),%edx
  10111d:	8b 45 08             	mov    0x8(%ebp),%eax
  101120:	8b 00                	mov    (%eax),%eax
  101122:	83 ec 04             	sub    $0x4,%esp
  101125:	51                   	push   %ecx
  101126:	52                   	push   %edx
  101127:	50                   	push   %eax
  101128:	e8 cb fc ff ff       	call   100df8 <drawBlock>
  10112d:	83 c4 10             	add    $0x10,%esp
}
  101130:	90                   	nop
  101131:	c9                   	leave  
  101132:	c3                   	ret    

00101133 <move>:

void move(int direction)
{
  101133:	55                   	push   %ebp
  101134:	89 e5                	mov    %esp,%ebp
  101136:	83 ec 08             	sub    $0x8,%esp
    moveBlock(&x, &y, direction, MBCOLOR,0);
  101139:	83 ec 0c             	sub    $0xc,%esp
  10113c:	6a 00                	push   $0x0
  10113e:	6a 5f                	push   $0x5f
  101140:	ff 75 08             	pushl  0x8(%ebp)
  101143:	68 6c 33 11 00       	push   $0x11336c
  101148:	68 40 39 10 00       	push   $0x103940
  10114d:	e8 a8 fe ff ff       	call   100ffa <moveBlock>
  101152:	83 c4 20             	add    $0x20,%esp
}
  101155:	90                   	nop
  101156:	c9                   	leave  
  101157:	c3                   	ret    

00101158 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  101158:	55                   	push   %ebp
  101159:	89 e5                	mov    %esp,%ebp
  10115b:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
  10115e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  101165:	eb 08                	jmp    10116f <strlen+0x17>
		n++;
  101167:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  10116b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10116f:	8b 45 08             	mov    0x8(%ebp),%eax
  101172:	0f b6 00             	movzbl (%eax),%eax
  101175:	84 c0                	test   %al,%al
  101177:	75 ee                	jne    101167 <strlen+0xf>
		n++;
	return n;
  101179:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10117c:	c9                   	leave  
  10117d:	c3                   	ret    

0010117e <strnlen>:

int
strnlen(const char *s, size_t size)
{
  10117e:	55                   	push   %ebp
  10117f:	89 e5                	mov    %esp,%ebp
  101181:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  101184:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10118b:	eb 0c                	jmp    101199 <strnlen+0x1b>
		n++;
  10118d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  101191:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  101195:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
  101199:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10119d:	74 0a                	je     1011a9 <strnlen+0x2b>
  10119f:	8b 45 08             	mov    0x8(%ebp),%eax
  1011a2:	0f b6 00             	movzbl (%eax),%eax
  1011a5:	84 c0                	test   %al,%al
  1011a7:	75 e4                	jne    10118d <strnlen+0xf>
		n++;
	return n;
  1011a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  1011ac:	c9                   	leave  
  1011ad:	c3                   	ret    

001011ae <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  1011ae:	55                   	push   %ebp
  1011af:	89 e5                	mov    %esp,%ebp
  1011b1:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
  1011b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1011b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
  1011ba:	90                   	nop
  1011bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1011be:	8d 50 01             	lea    0x1(%eax),%edx
  1011c1:	89 55 08             	mov    %edx,0x8(%ebp)
  1011c4:	8b 55 0c             	mov    0xc(%ebp),%edx
  1011c7:	8d 4a 01             	lea    0x1(%edx),%ecx
  1011ca:	89 4d 0c             	mov    %ecx,0xc(%ebp)
  1011cd:	0f b6 12             	movzbl (%edx),%edx
  1011d0:	88 10                	mov    %dl,(%eax)
  1011d2:	0f b6 00             	movzbl (%eax),%eax
  1011d5:	84 c0                	test   %al,%al
  1011d7:	75 e2                	jne    1011bb <strcpy+0xd>
		/* do nothing */;
	return ret;
  1011d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  1011dc:	c9                   	leave  
  1011dd:	c3                   	ret    

001011de <strcat>:

char *
strcat(char *dst, const char *src)
{
  1011de:	55                   	push   %ebp
  1011df:	89 e5                	mov    %esp,%ebp
  1011e1:	83 ec 10             	sub    $0x10,%esp
	int len = strlen(dst);
  1011e4:	ff 75 08             	pushl  0x8(%ebp)
  1011e7:	e8 6c ff ff ff       	call   101158 <strlen>
  1011ec:	83 c4 04             	add    $0x4,%esp
  1011ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
	strcpy(dst + len, src);
  1011f2:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1011f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1011f8:	01 d0                	add    %edx,%eax
  1011fa:	ff 75 0c             	pushl  0xc(%ebp)
  1011fd:	50                   	push   %eax
  1011fe:	e8 ab ff ff ff       	call   1011ae <strcpy>
  101203:	83 c4 08             	add    $0x8,%esp
	return dst;
  101206:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101209:	c9                   	leave  
  10120a:	c3                   	ret    

0010120b <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  10120b:	55                   	push   %ebp
  10120c:	89 e5                	mov    %esp,%ebp
  10120e:	83 ec 10             	sub    $0x10,%esp
	size_t i;
	char *ret;

	ret = dst;
  101211:	8b 45 08             	mov    0x8(%ebp),%eax
  101214:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
  101217:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10121e:	eb 23                	jmp    101243 <strncpy+0x38>
		*dst++ = *src;
  101220:	8b 45 08             	mov    0x8(%ebp),%eax
  101223:	8d 50 01             	lea    0x1(%eax),%edx
  101226:	89 55 08             	mov    %edx,0x8(%ebp)
  101229:	8b 55 0c             	mov    0xc(%ebp),%edx
  10122c:	0f b6 12             	movzbl (%edx),%edx
  10122f:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  101231:	8b 45 0c             	mov    0xc(%ebp),%eax
  101234:	0f b6 00             	movzbl (%eax),%eax
  101237:	84 c0                	test   %al,%al
  101239:	74 04                	je     10123f <strncpy+0x34>
			src++;
  10123b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  10123f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  101243:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101246:	3b 45 10             	cmp    0x10(%ebp),%eax
  101249:	72 d5                	jb     101220 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  10124b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  10124e:	c9                   	leave  
  10124f:	c3                   	ret    

00101250 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  101250:	55                   	push   %ebp
  101251:	89 e5                	mov    %esp,%ebp
  101253:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
  101256:	8b 45 08             	mov    0x8(%ebp),%eax
  101259:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
  10125c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  101260:	74 33                	je     101295 <strlcpy+0x45>
		while (--size > 0 && *src != '\0')
  101262:	eb 17                	jmp    10127b <strlcpy+0x2b>
			*dst++ = *src++;
  101264:	8b 45 08             	mov    0x8(%ebp),%eax
  101267:	8d 50 01             	lea    0x1(%eax),%edx
  10126a:	89 55 08             	mov    %edx,0x8(%ebp)
  10126d:	8b 55 0c             	mov    0xc(%ebp),%edx
  101270:	8d 4a 01             	lea    0x1(%edx),%ecx
  101273:	89 4d 0c             	mov    %ecx,0xc(%ebp)
  101276:	0f b6 12             	movzbl (%edx),%edx
  101279:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  10127b:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  10127f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  101283:	74 0a                	je     10128f <strlcpy+0x3f>
  101285:	8b 45 0c             	mov    0xc(%ebp),%eax
  101288:	0f b6 00             	movzbl (%eax),%eax
  10128b:	84 c0                	test   %al,%al
  10128d:	75 d5                	jne    101264 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
  10128f:	8b 45 08             	mov    0x8(%ebp),%eax
  101292:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  101295:	8b 55 08             	mov    0x8(%ebp),%edx
  101298:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10129b:	29 c2                	sub    %eax,%edx
  10129d:	89 d0                	mov    %edx,%eax
}
  10129f:	c9                   	leave  
  1012a0:	c3                   	ret    

001012a1 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  1012a1:	55                   	push   %ebp
  1012a2:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
  1012a4:	eb 08                	jmp    1012ae <strcmp+0xd>
		p++, q++;
  1012a6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1012aa:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  1012ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1012b1:	0f b6 00             	movzbl (%eax),%eax
  1012b4:	84 c0                	test   %al,%al
  1012b6:	74 10                	je     1012c8 <strcmp+0x27>
  1012b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1012bb:	0f b6 10             	movzbl (%eax),%edx
  1012be:	8b 45 0c             	mov    0xc(%ebp),%eax
  1012c1:	0f b6 00             	movzbl (%eax),%eax
  1012c4:	38 c2                	cmp    %al,%dl
  1012c6:	74 de                	je     1012a6 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  1012c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1012cb:	0f b6 00             	movzbl (%eax),%eax
  1012ce:	0f b6 d0             	movzbl %al,%edx
  1012d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1012d4:	0f b6 00             	movzbl (%eax),%eax
  1012d7:	0f b6 c0             	movzbl %al,%eax
  1012da:	29 c2                	sub    %eax,%edx
  1012dc:	89 d0                	mov    %edx,%eax
}
  1012de:	5d                   	pop    %ebp
  1012df:	c3                   	ret    

001012e0 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  1012e0:	55                   	push   %ebp
  1012e1:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
  1012e3:	eb 0c                	jmp    1012f1 <strncmp+0x11>
		n--, p++, q++;
  1012e5:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  1012e9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1012ed:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  1012f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1012f5:	74 1a                	je     101311 <strncmp+0x31>
  1012f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1012fa:	0f b6 00             	movzbl (%eax),%eax
  1012fd:	84 c0                	test   %al,%al
  1012ff:	74 10                	je     101311 <strncmp+0x31>
  101301:	8b 45 08             	mov    0x8(%ebp),%eax
  101304:	0f b6 10             	movzbl (%eax),%edx
  101307:	8b 45 0c             	mov    0xc(%ebp),%eax
  10130a:	0f b6 00             	movzbl (%eax),%eax
  10130d:	38 c2                	cmp    %al,%dl
  10130f:	74 d4                	je     1012e5 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
  101311:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  101315:	75 07                	jne    10131e <strncmp+0x3e>
		return 0;
  101317:	b8 00 00 00 00       	mov    $0x0,%eax
  10131c:	eb 16                	jmp    101334 <strncmp+0x54>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  10131e:	8b 45 08             	mov    0x8(%ebp),%eax
  101321:	0f b6 00             	movzbl (%eax),%eax
  101324:	0f b6 d0             	movzbl %al,%edx
  101327:	8b 45 0c             	mov    0xc(%ebp),%eax
  10132a:	0f b6 00             	movzbl (%eax),%eax
  10132d:	0f b6 c0             	movzbl %al,%eax
  101330:	29 c2                	sub    %eax,%edx
  101332:	89 d0                	mov    %edx,%eax
}
  101334:	5d                   	pop    %ebp
  101335:	c3                   	ret    

00101336 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  101336:	55                   	push   %ebp
  101337:	89 e5                	mov    %esp,%ebp
  101339:	83 ec 04             	sub    $0x4,%esp
  10133c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10133f:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
  101342:	eb 14                	jmp    101358 <strchr+0x22>
		if (*s == c)
  101344:	8b 45 08             	mov    0x8(%ebp),%eax
  101347:	0f b6 00             	movzbl (%eax),%eax
  10134a:	3a 45 fc             	cmp    -0x4(%ebp),%al
  10134d:	75 05                	jne    101354 <strchr+0x1e>
			return (char *) s;
  10134f:	8b 45 08             	mov    0x8(%ebp),%eax
  101352:	eb 13                	jmp    101367 <strchr+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  101354:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  101358:	8b 45 08             	mov    0x8(%ebp),%eax
  10135b:	0f b6 00             	movzbl (%eax),%eax
  10135e:	84 c0                	test   %al,%al
  101360:	75 e2                	jne    101344 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
  101362:	b8 00 00 00 00       	mov    $0x0,%eax
}
  101367:	c9                   	leave  
  101368:	c3                   	ret    

00101369 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  101369:	55                   	push   %ebp
  10136a:	89 e5                	mov    %esp,%ebp
  10136c:	83 ec 04             	sub    $0x4,%esp
  10136f:	8b 45 0c             	mov    0xc(%ebp),%eax
  101372:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
  101375:	eb 0f                	jmp    101386 <strfind+0x1d>
		if (*s == c)
  101377:	8b 45 08             	mov    0x8(%ebp),%eax
  10137a:	0f b6 00             	movzbl (%eax),%eax
  10137d:	3a 45 fc             	cmp    -0x4(%ebp),%al
  101380:	74 10                	je     101392 <strfind+0x29>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  101382:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  101386:	8b 45 08             	mov    0x8(%ebp),%eax
  101389:	0f b6 00             	movzbl (%eax),%eax
  10138c:	84 c0                	test   %al,%al
  10138e:	75 e7                	jne    101377 <strfind+0xe>
  101390:	eb 01                	jmp    101393 <strfind+0x2a>
		if (*s == c)
			break;
  101392:	90                   	nop
	return (char *) s;
  101393:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101396:	c9                   	leave  
  101397:	c3                   	ret    

00101398 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  101398:	55                   	push   %ebp
  101399:	89 e5                	mov    %esp,%ebp
  10139b:	57                   	push   %edi
	//char *p;

	if (n == 0)
  10139c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1013a0:	75 05                	jne    1013a7 <memset+0xf>
		return v;
  1013a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1013a5:	eb 5c                	jmp    101403 <memset+0x6b>
	if ((int)v%4 == 0 && n%4 == 0) {
  1013a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1013aa:	83 e0 03             	and    $0x3,%eax
  1013ad:	85 c0                	test   %eax,%eax
  1013af:	75 41                	jne    1013f2 <memset+0x5a>
  1013b1:	8b 45 10             	mov    0x10(%ebp),%eax
  1013b4:	83 e0 03             	and    $0x3,%eax
  1013b7:	85 c0                	test   %eax,%eax
  1013b9:	75 37                	jne    1013f2 <memset+0x5a>
		c &= 0xFF;
  1013bb:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  1013c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1013c5:	c1 e0 18             	shl    $0x18,%eax
  1013c8:	89 c2                	mov    %eax,%edx
  1013ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  1013cd:	c1 e0 10             	shl    $0x10,%eax
  1013d0:	09 c2                	or     %eax,%edx
  1013d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1013d5:	c1 e0 08             	shl    $0x8,%eax
  1013d8:	09 d0                	or     %edx,%eax
  1013da:	09 45 0c             	or     %eax,0xc(%ebp)
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  1013dd:	8b 45 10             	mov    0x10(%ebp),%eax
  1013e0:	c1 e8 02             	shr    $0x2,%eax
  1013e3:	89 c1                	mov    %eax,%ecx
	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  1013e5:	8b 55 08             	mov    0x8(%ebp),%edx
  1013e8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1013eb:	89 d7                	mov    %edx,%edi
  1013ed:	fc                   	cld    
  1013ee:	f3 ab                	rep stos %eax,%es:(%edi)
  1013f0:	eb 0e                	jmp    101400 <memset+0x68>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  1013f2:	8b 55 08             	mov    0x8(%ebp),%edx
  1013f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1013f8:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1013fb:	89 d7                	mov    %edx,%edi
  1013fd:	fc                   	cld    
  1013fe:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
  101400:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101403:	5f                   	pop    %edi
  101404:	5d                   	pop    %ebp
  101405:	c3                   	ret    

00101406 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  101406:	55                   	push   %ebp
  101407:	89 e5                	mov    %esp,%ebp
  101409:	57                   	push   %edi
  10140a:	56                   	push   %esi
  10140b:	53                   	push   %ebx
  10140c:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
  10140f:	8b 45 0c             	mov    0xc(%ebp),%eax
  101412:	89 45 f0             	mov    %eax,-0x10(%ebp)
	d = dst;
  101415:	8b 45 08             	mov    0x8(%ebp),%eax
  101418:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (s < d && s + n > d) {
  10141b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10141e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  101421:	73 6d                	jae    101490 <memmove+0x8a>
  101423:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101426:	8b 45 10             	mov    0x10(%ebp),%eax
  101429:	01 d0                	add    %edx,%eax
  10142b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10142e:	76 60                	jbe    101490 <memmove+0x8a>
		s += n;
  101430:	8b 45 10             	mov    0x10(%ebp),%eax
  101433:	01 45 f0             	add    %eax,-0x10(%ebp)
		d += n;
  101436:	8b 45 10             	mov    0x10(%ebp),%eax
  101439:	01 45 ec             	add    %eax,-0x14(%ebp)
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  10143c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10143f:	83 e0 03             	and    $0x3,%eax
  101442:	85 c0                	test   %eax,%eax
  101444:	75 2f                	jne    101475 <memmove+0x6f>
  101446:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101449:	83 e0 03             	and    $0x3,%eax
  10144c:	85 c0                	test   %eax,%eax
  10144e:	75 25                	jne    101475 <memmove+0x6f>
  101450:	8b 45 10             	mov    0x10(%ebp),%eax
  101453:	83 e0 03             	and    $0x3,%eax
  101456:	85 c0                	test   %eax,%eax
  101458:	75 1b                	jne    101475 <memmove+0x6f>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  10145a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10145d:	83 e8 04             	sub    $0x4,%eax
  101460:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101463:	83 ea 04             	sub    $0x4,%edx
  101466:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101469:	c1 e9 02             	shr    $0x2,%ecx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  10146c:	89 c7                	mov    %eax,%edi
  10146e:	89 d6                	mov    %edx,%esi
  101470:	fd                   	std    
  101471:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  101473:	eb 18                	jmp    10148d <memmove+0x87>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  101475:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101478:	8d 50 ff             	lea    -0x1(%eax),%edx
  10147b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10147e:	8d 58 ff             	lea    -0x1(%eax),%ebx
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  101481:	8b 45 10             	mov    0x10(%ebp),%eax
  101484:	89 d7                	mov    %edx,%edi
  101486:	89 de                	mov    %ebx,%esi
  101488:	89 c1                	mov    %eax,%ecx
  10148a:	fd                   	std    
  10148b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  10148d:	fc                   	cld    
  10148e:	eb 45                	jmp    1014d5 <memmove+0xcf>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  101490:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101493:	83 e0 03             	and    $0x3,%eax
  101496:	85 c0                	test   %eax,%eax
  101498:	75 2b                	jne    1014c5 <memmove+0xbf>
  10149a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10149d:	83 e0 03             	and    $0x3,%eax
  1014a0:	85 c0                	test   %eax,%eax
  1014a2:	75 21                	jne    1014c5 <memmove+0xbf>
  1014a4:	8b 45 10             	mov    0x10(%ebp),%eax
  1014a7:	83 e0 03             	and    $0x3,%eax
  1014aa:	85 c0                	test   %eax,%eax
  1014ac:	75 17                	jne    1014c5 <memmove+0xbf>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  1014ae:	8b 45 10             	mov    0x10(%ebp),%eax
  1014b1:	c1 e8 02             	shr    $0x2,%eax
  1014b4:	89 c1                	mov    %eax,%ecx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  1014b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1014b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1014bc:	89 c7                	mov    %eax,%edi
  1014be:	89 d6                	mov    %edx,%esi
  1014c0:	fc                   	cld    
  1014c1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  1014c3:	eb 10                	jmp    1014d5 <memmove+0xcf>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  1014c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1014c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1014cb:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1014ce:	89 c7                	mov    %eax,%edi
  1014d0:	89 d6                	mov    %edx,%esi
  1014d2:	fc                   	cld    
  1014d3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  1014d5:	8b 45 08             	mov    0x8(%ebp),%eax
}
  1014d8:	83 c4 10             	add    $0x10,%esp
  1014db:	5b                   	pop    %ebx
  1014dc:	5e                   	pop    %esi
  1014dd:	5f                   	pop    %edi
  1014de:	5d                   	pop    %ebp
  1014df:	c3                   	ret    

001014e0 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  1014e0:	55                   	push   %ebp
  1014e1:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  1014e3:	ff 75 10             	pushl  0x10(%ebp)
  1014e6:	ff 75 0c             	pushl  0xc(%ebp)
  1014e9:	ff 75 08             	pushl  0x8(%ebp)
  1014ec:	e8 15 ff ff ff       	call   101406 <memmove>
  1014f1:	83 c4 0c             	add    $0xc,%esp
}
  1014f4:	c9                   	leave  
  1014f5:	c3                   	ret    

001014f6 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  1014f6:	55                   	push   %ebp
  1014f7:	89 e5                	mov    %esp,%ebp
  1014f9:	83 ec 10             	sub    $0x10,%esp
	const uint8_t *s1 = (const uint8_t *) v1;
  1014fc:	8b 45 08             	mov    0x8(%ebp),%eax
  1014ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8_t *s2 = (const uint8_t *) v2;
  101502:	8b 45 0c             	mov    0xc(%ebp),%eax
  101505:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
  101508:	eb 30                	jmp    10153a <memcmp+0x44>
		if (*s1 != *s2)
  10150a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10150d:	0f b6 10             	movzbl (%eax),%edx
  101510:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101513:	0f b6 00             	movzbl (%eax),%eax
  101516:	38 c2                	cmp    %al,%dl
  101518:	74 18                	je     101532 <memcmp+0x3c>
			return (int) *s1 - (int) *s2;
  10151a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10151d:	0f b6 00             	movzbl (%eax),%eax
  101520:	0f b6 d0             	movzbl %al,%edx
  101523:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101526:	0f b6 00             	movzbl (%eax),%eax
  101529:	0f b6 c0             	movzbl %al,%eax
  10152c:	29 c2                	sub    %eax,%edx
  10152e:	89 d0                	mov    %edx,%eax
  101530:	eb 1a                	jmp    10154c <memcmp+0x56>
		s1++, s2++;
  101532:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  101536:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  10153a:	8b 45 10             	mov    0x10(%ebp),%eax
  10153d:	8d 50 ff             	lea    -0x1(%eax),%edx
  101540:	89 55 10             	mov    %edx,0x10(%ebp)
  101543:	85 c0                	test   %eax,%eax
  101545:	75 c3                	jne    10150a <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  101547:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10154c:	c9                   	leave  
  10154d:	c3                   	ret    

0010154e <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  10154e:	55                   	push   %ebp
  10154f:	89 e5                	mov    %esp,%ebp
  101551:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
  101554:	8b 55 08             	mov    0x8(%ebp),%edx
  101557:	8b 45 10             	mov    0x10(%ebp),%eax
  10155a:	01 d0                	add    %edx,%eax
  10155c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
  10155f:	eb 17                	jmp    101578 <memfind+0x2a>
		if (*(const unsigned char *) s == (unsigned char) c)
  101561:	8b 45 08             	mov    0x8(%ebp),%eax
  101564:	0f b6 00             	movzbl (%eax),%eax
  101567:	0f b6 d0             	movzbl %al,%edx
  10156a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10156d:	0f b6 c0             	movzbl %al,%eax
  101570:	39 c2                	cmp    %eax,%edx
  101572:	74 0e                	je     101582 <memfind+0x34>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  101574:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  101578:	8b 45 08             	mov    0x8(%ebp),%eax
  10157b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  10157e:	72 e1                	jb     101561 <memfind+0x13>
  101580:	eb 01                	jmp    101583 <memfind+0x35>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  101582:	90                   	nop
	return (void *) s;
  101583:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101586:	c9                   	leave  
  101587:	c3                   	ret    

00101588 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  101588:	55                   	push   %ebp
  101589:	89 e5                	mov    %esp,%ebp
  10158b:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
  10158e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
  101595:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  10159c:	eb 04                	jmp    1015a2 <strtol+0x1a>
		s++;
  10159e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  1015a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1015a5:	0f b6 00             	movzbl (%eax),%eax
  1015a8:	3c 20                	cmp    $0x20,%al
  1015aa:	74 f2                	je     10159e <strtol+0x16>
  1015ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1015af:	0f b6 00             	movzbl (%eax),%eax
  1015b2:	3c 09                	cmp    $0x9,%al
  1015b4:	74 e8                	je     10159e <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
  1015b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1015b9:	0f b6 00             	movzbl (%eax),%eax
  1015bc:	3c 2b                	cmp    $0x2b,%al
  1015be:	75 06                	jne    1015c6 <strtol+0x3e>
		s++;
  1015c0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1015c4:	eb 15                	jmp    1015db <strtol+0x53>
	else if (*s == '-')
  1015c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1015c9:	0f b6 00             	movzbl (%eax),%eax
  1015cc:	3c 2d                	cmp    $0x2d,%al
  1015ce:	75 0b                	jne    1015db <strtol+0x53>
		s++, neg = 1;
  1015d0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1015d4:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  1015db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1015df:	74 06                	je     1015e7 <strtol+0x5f>
  1015e1:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  1015e5:	75 24                	jne    10160b <strtol+0x83>
  1015e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1015ea:	0f b6 00             	movzbl (%eax),%eax
  1015ed:	3c 30                	cmp    $0x30,%al
  1015ef:	75 1a                	jne    10160b <strtol+0x83>
  1015f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1015f4:	83 c0 01             	add    $0x1,%eax
  1015f7:	0f b6 00             	movzbl (%eax),%eax
  1015fa:	3c 78                	cmp    $0x78,%al
  1015fc:	75 0d                	jne    10160b <strtol+0x83>
		s += 2, base = 16;
  1015fe:	83 45 08 02          	addl   $0x2,0x8(%ebp)
  101602:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
  101609:	eb 2a                	jmp    101635 <strtol+0xad>
	else if (base == 0 && s[0] == '0')
  10160b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10160f:	75 17                	jne    101628 <strtol+0xa0>
  101611:	8b 45 08             	mov    0x8(%ebp),%eax
  101614:	0f b6 00             	movzbl (%eax),%eax
  101617:	3c 30                	cmp    $0x30,%al
  101619:	75 0d                	jne    101628 <strtol+0xa0>
		s++, base = 8;
  10161b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10161f:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
  101626:	eb 0d                	jmp    101635 <strtol+0xad>
	else if (base == 0)
  101628:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10162c:	75 07                	jne    101635 <strtol+0xad>
		base = 10;
  10162e:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  101635:	8b 45 08             	mov    0x8(%ebp),%eax
  101638:	0f b6 00             	movzbl (%eax),%eax
  10163b:	3c 2f                	cmp    $0x2f,%al
  10163d:	7e 1b                	jle    10165a <strtol+0xd2>
  10163f:	8b 45 08             	mov    0x8(%ebp),%eax
  101642:	0f b6 00             	movzbl (%eax),%eax
  101645:	3c 39                	cmp    $0x39,%al
  101647:	7f 11                	jg     10165a <strtol+0xd2>
			dig = *s - '0';
  101649:	8b 45 08             	mov    0x8(%ebp),%eax
  10164c:	0f b6 00             	movzbl (%eax),%eax
  10164f:	0f be c0             	movsbl %al,%eax
  101652:	83 e8 30             	sub    $0x30,%eax
  101655:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101658:	eb 48                	jmp    1016a2 <strtol+0x11a>
		else if (*s >= 'a' && *s <= 'z')
  10165a:	8b 45 08             	mov    0x8(%ebp),%eax
  10165d:	0f b6 00             	movzbl (%eax),%eax
  101660:	3c 60                	cmp    $0x60,%al
  101662:	7e 1b                	jle    10167f <strtol+0xf7>
  101664:	8b 45 08             	mov    0x8(%ebp),%eax
  101667:	0f b6 00             	movzbl (%eax),%eax
  10166a:	3c 7a                	cmp    $0x7a,%al
  10166c:	7f 11                	jg     10167f <strtol+0xf7>
			dig = *s - 'a' + 10;
  10166e:	8b 45 08             	mov    0x8(%ebp),%eax
  101671:	0f b6 00             	movzbl (%eax),%eax
  101674:	0f be c0             	movsbl %al,%eax
  101677:	83 e8 57             	sub    $0x57,%eax
  10167a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10167d:	eb 23                	jmp    1016a2 <strtol+0x11a>
		else if (*s >= 'A' && *s <= 'Z')
  10167f:	8b 45 08             	mov    0x8(%ebp),%eax
  101682:	0f b6 00             	movzbl (%eax),%eax
  101685:	3c 40                	cmp    $0x40,%al
  101687:	7e 3c                	jle    1016c5 <strtol+0x13d>
  101689:	8b 45 08             	mov    0x8(%ebp),%eax
  10168c:	0f b6 00             	movzbl (%eax),%eax
  10168f:	3c 5a                	cmp    $0x5a,%al
  101691:	7f 32                	jg     1016c5 <strtol+0x13d>
			dig = *s - 'A' + 10;
  101693:	8b 45 08             	mov    0x8(%ebp),%eax
  101696:	0f b6 00             	movzbl (%eax),%eax
  101699:	0f be c0             	movsbl %al,%eax
  10169c:	83 e8 37             	sub    $0x37,%eax
  10169f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
  1016a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1016a5:	3b 45 10             	cmp    0x10(%ebp),%eax
  1016a8:	7d 1a                	jge    1016c4 <strtol+0x13c>
			break;
		s++, val = (val * base) + dig;
  1016aa:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  1016ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1016b1:	0f af 45 10          	imul   0x10(%ebp),%eax
  1016b5:	89 c2                	mov    %eax,%edx
  1016b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1016ba:	01 d0                	add    %edx,%eax
  1016bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
  1016bf:	e9 71 ff ff ff       	jmp    101635 <strtol+0xad>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  1016c4:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  1016c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1016c9:	74 08                	je     1016d3 <strtol+0x14b>
		*endptr = (char *) s;
  1016cb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1016ce:	8b 55 08             	mov    0x8(%ebp),%edx
  1016d1:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
  1016d3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1016d7:	74 07                	je     1016e0 <strtol+0x158>
  1016d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1016dc:	f7 d8                	neg    %eax
  1016de:	eb 03                	jmp    1016e3 <strtol+0x15b>
  1016e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  1016e3:	c9                   	leave  
  1016e4:	c3                   	ret    

001016e5 <init_list>:
#include<lib/blocklist.h>
NODE blocks[NODENUM];
NODE* head,*tail;
void init_list(){
  1016e5:	55                   	push   %ebp
  1016e6:	89 e5                	mov    %esp,%ebp
  1016e8:	83 ec 10             	sub    $0x10,%esp
    for(int i=0;i<NODENUM;i++){
  1016eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1016f2:	eb 15                	jmp    101709 <init_list+0x24>
        blocks[i].y=INF;
  1016f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1016f7:	c1 e0 04             	shl    $0x4,%eax
  1016fa:	05 84 33 11 00       	add    $0x113384,%eax
  1016ff:	c7 00 90 90 90 00    	movl   $0x909090,(%eax)
#include<lib/blocklist.h>
NODE blocks[NODENUM];
NODE* head,*tail;
void init_list(){
    for(int i=0;i<NODENUM;i++){
  101705:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  101709:	81 7d fc e7 03 00 00 	cmpl   $0x3e7,-0x4(%ebp)
  101710:	7e e2                	jle    1016f4 <init_list+0xf>
        blocks[i].y=INF;
    }
    head=&blocks[0];
  101712:	c7 05 04 72 11 00 80 	movl   $0x113380,0x117204
  101719:	33 11 00 
    blocks[0].x=0;
  10171c:	c7 05 80 33 11 00 00 	movl   $0x0,0x113380
  101723:	00 00 00 
    blocks[0].y=150;
  101726:	c7 05 84 33 11 00 96 	movl   $0x96,0x113384
  10172d:	00 00 00 
    blocks[0].next=tail;
  101730:	a1 00 72 11 00       	mov    0x117200,%eax
  101735:	a3 88 33 11 00       	mov    %eax,0x113388
    tail=blocks[0].next;
  10173a:	a1 88 33 11 00       	mov    0x113388,%eax
  10173f:	a3 00 72 11 00       	mov    %eax,0x117200
    tail->prev=&blocks[0];
  101744:	a1 00 72 11 00       	mov    0x117200,%eax
  101749:	c7 40 0c 80 33 11 00 	movl   $0x113380,0xc(%eax)
}
  101750:	90                   	nop
  101751:	c9                   	leave  
  101752:	c3                   	ret    

00101753 <get_head>:

NODE* get_head(){
  101753:	55                   	push   %ebp
  101754:	89 e5                	mov    %esp,%ebp
    return head;
  101756:	a1 04 72 11 00       	mov    0x117204,%eax
}
  10175b:	5d                   	pop    %ebp
  10175c:	c3                   	ret    

0010175d <get_tail>:
NODE* get_tail(){
  10175d:	55                   	push   %ebp
  10175e:	89 e5                	mov    %esp,%ebp
    return tail;
  101760:	a1 00 72 11 00       	mov    0x117200,%eax
}
  101765:	5d                   	pop    %ebp
  101766:	c3                   	ret    

00101767 <add>:
void add(int x,int y){
  101767:	55                   	push   %ebp
  101768:	89 e5                	mov    %esp,%ebp
  10176a:	83 ec 10             	sub    $0x10,%esp
    for(int i=0;i<NODENUM;i++){
  10176d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  101774:	e9 90 00 00 00       	jmp    101809 <add+0xa2>
        if(blocks[i].y==INF){
  101779:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10177c:	c1 e0 04             	shl    $0x4,%eax
  10177f:	05 84 33 11 00       	add    $0x113384,%eax
  101784:	8b 00                	mov    (%eax),%eax
  101786:	3d 90 90 90 00       	cmp    $0x909090,%eax
  10178b:	75 78                	jne    101805 <add+0x9e>
            blocks[i].x=x;
  10178d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101790:	c1 e0 04             	shl    $0x4,%eax
  101793:	8d 90 80 33 11 00    	lea    0x113380(%eax),%edx
  101799:	8b 45 08             	mov    0x8(%ebp),%eax
  10179c:	89 02                	mov    %eax,(%edx)
            blocks[i].y=y;
  10179e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1017a1:	c1 e0 04             	shl    $0x4,%eax
  1017a4:	8d 90 84 33 11 00    	lea    0x113384(%eax),%edx
  1017aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1017ad:	89 02                	mov    %eax,(%edx)
            tail->prev->next=&blocks[i];
  1017af:	a1 00 72 11 00       	mov    0x117200,%eax
  1017b4:	8b 40 0c             	mov    0xc(%eax),%eax
  1017b7:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1017ba:	c1 e2 04             	shl    $0x4,%edx
  1017bd:	81 c2 80 33 11 00    	add    $0x113380,%edx
  1017c3:	89 50 08             	mov    %edx,0x8(%eax)
            blocks[i].prev=tail->prev;
  1017c6:	a1 00 72 11 00       	mov    0x117200,%eax
  1017cb:	8b 40 0c             	mov    0xc(%eax),%eax
  1017ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1017d1:	c1 e2 04             	shl    $0x4,%edx
  1017d4:	81 c2 8c 33 11 00    	add    $0x11338c,%edx
  1017da:	89 02                	mov    %eax,(%edx)
            tail->prev=&blocks[i];
  1017dc:	a1 00 72 11 00       	mov    0x117200,%eax
  1017e1:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1017e4:	c1 e2 04             	shl    $0x4,%edx
  1017e7:	81 c2 80 33 11 00    	add    $0x113380,%edx
  1017ed:	89 50 0c             	mov    %edx,0xc(%eax)
            blocks[i].next=tail;
  1017f0:	a1 00 72 11 00       	mov    0x117200,%eax
  1017f5:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1017f8:	c1 e2 04             	shl    $0x4,%edx
  1017fb:	81 c2 88 33 11 00    	add    $0x113388,%edx
  101801:	89 02                	mov    %eax,(%edx)
            return;
  101803:	eb 11                	jmp    101816 <add+0xaf>
}
NODE* get_tail(){
    return tail;
}
void add(int x,int y){
    for(int i=0;i<NODENUM;i++){
  101805:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  101809:	81 7d fc e7 03 00 00 	cmpl   $0x3e7,-0x4(%ebp)
  101810:	0f 8e 63 ff ff ff    	jle    101779 <add+0x12>
            tail->prev=&blocks[i];
            blocks[i].next=tail;
            return;
        }
    }
}
  101816:	c9                   	leave  
  101817:	c3                   	ret    

00101818 <del>:

NODE* del(NODE* node){
  101818:	55                   	push   %ebp
  101819:	89 e5                	mov    %esp,%ebp
  10181b:	83 ec 10             	sub    $0x10,%esp
    if(head->x==node->x&&head->y==node->y){
  10181e:	a1 04 72 11 00       	mov    0x117204,%eax
  101823:	8b 10                	mov    (%eax),%edx
  101825:	8b 45 08             	mov    0x8(%ebp),%eax
  101828:	8b 00                	mov    (%eax),%eax
  10182a:	39 c2                	cmp    %eax,%edx
  10182c:	75 1f                	jne    10184d <del+0x35>
  10182e:	a1 04 72 11 00       	mov    0x117204,%eax
  101833:	8b 50 04             	mov    0x4(%eax),%edx
  101836:	8b 45 08             	mov    0x8(%ebp),%eax
  101839:	8b 40 04             	mov    0x4(%eax),%eax
  10183c:	39 c2                	cmp    %eax,%edx
  10183e:	75 0d                	jne    10184d <del+0x35>
        head=head->next;
  101840:	a1 04 72 11 00       	mov    0x117204,%eax
  101845:	8b 40 08             	mov    0x8(%eax),%eax
  101848:	a3 04 72 11 00       	mov    %eax,0x117204
    }
    NODE* next=node->next;
  10184d:	8b 45 08             	mov    0x8(%ebp),%eax
  101850:	8b 40 08             	mov    0x8(%eax),%eax
  101853:	89 45 fc             	mov    %eax,-0x4(%ebp)
    node->prev->next=node->next;
  101856:	8b 45 08             	mov    0x8(%ebp),%eax
  101859:	8b 40 0c             	mov    0xc(%eax),%eax
  10185c:	8b 55 08             	mov    0x8(%ebp),%edx
  10185f:	8b 52 08             	mov    0x8(%edx),%edx
  101862:	89 50 08             	mov    %edx,0x8(%eax)
    node->next->prev=node->prev;
  101865:	8b 45 08             	mov    0x8(%ebp),%eax
  101868:	8b 40 08             	mov    0x8(%eax),%eax
  10186b:	8b 55 08             	mov    0x8(%ebp),%edx
  10186e:	8b 52 0c             	mov    0xc(%edx),%edx
  101871:	89 50 0c             	mov    %edx,0xc(%eax)
    node->y=INF;
  101874:	8b 45 08             	mov    0x8(%ebp),%eax
  101877:	c7 40 04 90 90 90 00 	movl   $0x909090,0x4(%eax)
    return next;
  10187e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  101881:	c9                   	leave  
  101882:	c3                   	ret    

00101883 <get_key>:
};
static int keydown[26]={0};

static int lastkey;

int8_t get_key(char s){
  101883:	55                   	push   %ebp
  101884:	89 e5                	mov    %esp,%ebp
  101886:	83 ec 04             	sub    $0x4,%esp
  101889:	8b 45 08             	mov    0x8(%ebp),%eax
  10188c:	88 45 fc             	mov    %al,-0x4(%ebp)
	return keydown[s-'a'];
  10188f:	0f be 45 fc          	movsbl -0x4(%ebp),%eax
  101893:	83 e8 61             	sub    $0x61,%eax
  101896:	8b 04 85 c0 30 10 00 	mov    0x1030c0(,%eax,4),%eax
}
  10189d:	c9                   	leave  
  10189e:	c3                   	ret    

0010189f <get_lastkey>:
int8_t get_lastkey(){
  10189f:	55                   	push   %ebp
  1018a0:	89 e5                	mov    %esp,%ebp
	return lastkey+'a';
  1018a2:	a1 28 31 10 00       	mov    0x103128,%eax
  1018a7:	83 c0 61             	add    $0x61,%eax
}
  1018aa:	5d                   	pop    %ebp
  1018ab:	c3                   	ret    

001018ac <press_key>:
void press_key(int code){
  1018ac:	55                   	push   %ebp
  1018ad:	89 e5                	mov    %esp,%ebp
  1018af:	83 ec 10             	sub    $0x10,%esp
	int i=0;
  1018b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	//printk("haha\n");
	if((code & 0x80) == 0){
  1018b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1018bc:	25 80 00 00 00       	and    $0x80,%eax
  1018c1:	85 c0                	test   %eax,%eax
  1018c3:	75 35                	jne    1018fa <press_key+0x4e>
		for(;i<26;i++){
  1018c5:	eb 2b                	jmp    1018f2 <press_key+0x46>
			if(letter[i]==code){
  1018c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1018ca:	8b 04 85 20 30 10 00 	mov    0x103020(,%eax,4),%eax
  1018d1:	3b 45 08             	cmp    0x8(%ebp),%eax
  1018d4:	75 18                	jne    1018ee <press_key+0x42>
				keydown[i] = 1;
  1018d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1018d9:	c7 04 85 c0 30 10 00 	movl   $0x1,0x1030c0(,%eax,4)
  1018e0:	01 00 00 00 
				lastkey = i;
  1018e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1018e7:	a3 28 31 10 00       	mov    %eax,0x103128
				return;
  1018ec:	eb 3b                	jmp    101929 <press_key+0x7d>
}
void press_key(int code){
	int i=0;
	//printk("haha\n");
	if((code & 0x80) == 0){
		for(;i<26;i++){
  1018ee:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1018f2:	83 7d fc 19          	cmpl   $0x19,-0x4(%ebp)
  1018f6:	7e cf                	jle    1018c7 <press_key+0x1b>
  1018f8:	eb 2f                	jmp    101929 <press_key+0x7d>
				lastkey = i;
				return;
			}
		}
	}else{
		code &= 0x7F;
  1018fa:	83 65 08 7f          	andl   $0x7f,0x8(%ebp)
		for(;i<26;i++){
  1018fe:	eb 23                	jmp    101923 <press_key+0x77>
			if(letter[i]==code){
  101900:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101903:	8b 04 85 20 30 10 00 	mov    0x103020(,%eax,4),%eax
  10190a:	3b 45 08             	cmp    0x8(%ebp),%eax
  10190d:	75 10                	jne    10191f <press_key+0x73>
				keydown[i] = 0;
  10190f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101912:	c7 04 85 c0 30 10 00 	movl   $0x0,0x1030c0(,%eax,4)
  101919:	00 00 00 00 
				return;
  10191d:	eb 0a                	jmp    101929 <press_key+0x7d>
				return;
			}
		}
	}else{
		code &= 0x7F;
		for(;i<26;i++){
  10191f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  101923:	83 7d fc 19          	cmpl   $0x19,-0x4(%ebp)
  101927:	7e d7                	jle    101900 <press_key+0x54>
				keydown[i] = 0;
				return;
			}
		}
	}
}
  101929:	c9                   	leave  
  10192a:	c3                   	ret    

0010192b <srand>:
#include "lib/random.h"
static int seed = 0;

void
srand(int s) {
  10192b:	55                   	push   %ebp
  10192c:	89 e5                	mov    %esp,%ebp
	seed = s;
  10192e:	8b 45 08             	mov    0x8(%ebp),%eax
  101931:	a3 2c 31 10 00       	mov    %eax,0x10312c
}
  101936:	90                   	nop
  101937:	5d                   	pop    %ebp
  101938:	c3                   	ret    

00101939 <rand>:

/* 生成下一个随机数 */
int
rand(void) {
  101939:	55                   	push   %ebp
  10193a:	89 e5                	mov    %esp,%ebp
	seed = 0x015A4E35 * seed + 1;
  10193c:	a1 2c 31 10 00       	mov    0x10312c,%eax
  101941:	69 c0 35 4e 5a 01    	imul   $0x15a4e35,%eax,%eax
  101947:	83 c0 01             	add    $0x1,%eax
  10194a:	a3 2c 31 10 00       	mov    %eax,0x10312c
	return (seed >> 16) & 0x7FFF;
  10194f:	a1 2c 31 10 00       	mov    0x10312c,%eax
  101954:	c1 f8 10             	sar    $0x10,%eax
  101957:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
  10195c:	5d                   	pop    %ebp
  10195d:	c3                   	ret    
